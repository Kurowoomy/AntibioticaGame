{"version":3,"sources":["webpack://iching/webpack/universalModuleDefinition","webpack://iching/webpack/bootstrap","webpack://iching/./src/core/common/reedsolomon/BinaryGFPoly.ts","webpack://iching/./src/core/BitMatrix.ts","webpack://iching/./src/core/encoder/Encoder.ts","webpack://iching/./src/core/Matrix.ts","webpack://iching/./src/core/ByteMatrix.ts","webpack://iching/./src/core/common/reedsolomon/index.ts","webpack://iching/./src/core/encoder/writer/index.ts","webpack://iching/./src/core/utils.ts","webpack://iching/./src/core/decoder/locator/PatternLocator.ts","webpack://iching/./src/core/geometry.ts","webpack://iching/./src/index.ts","webpack://iching/./src/core/decoder/index.ts","webpack://iching/./src/core/decoder/binarizer/index.ts","webpack://iching/./src/core/decoder/binarizer/FastAdaptiveBinarizer.ts","webpack://iching/./src/core/decoder/binarizer/Binarizer.ts","webpack://iching/./src/core/decoder/Decoder.ts","webpack://iching/./src/core/common/reedsolomon/BinaryGF.ts","webpack://iching/./src/core/common/reedsolomon/ReedSolomonEncoder.ts","webpack://iching/./src/core/common/reedsolomon/ReedSolomonDecoder.ts","webpack://iching/./src/core/decoder/extractor/index.ts","webpack://iching/./src/core/decoder/extractor/Extractor.ts","webpack://iching/./src/core/encoder/writer/Writer.ts","webpack://iching/./src/core/decoder/locator/index.ts","webpack://iching/./src/core/decoder/locator/Locator.ts","webpack://iching/./src/core/decoder/transform/index.ts","webpack://iching/./src/core/decoder/transform/CodeTranform.ts","webpack://iching/./src/core/decoder/transform/PerspectiveTransform.ts","webpack://iching/./src/core/decoder/transform/TransformationMatrix.ts","webpack://iching/./src/core/encoder/index.ts"],"names":["root","factory","exports","module","define","amd","iching","window","t","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","e","this","__values","iterator","next","length","done","BinaryGFPoly","field","coefficients","Error","leading","slice","getDegree","getCoefficients","getCoefficient","degree","evaluateAt","x","res","_b","_c","co","add","multiply","other","isZero","resLength","Math","max","resCoefficients","Uint8ClampedArray","multiplyPoly","getZeroPoly","isOne","j","a","b","multiplyScalar","dividePoly","normalizer","divide","coef","remainderLength","BitMatrix","_super","__extends","set","y","data","width","toImage","height","idx","color","Matrix","reedsolomon_1","Encoder","encode","payload","ecLevel","ecSymbols","ceil","SYMBOLS_PER_ERROR","minimumSize","OFFSET","MAX_SIZE","sideLength","trueSize","VERSION","toUpperCase","mappedChar","ALPHABET","indexOf","encodedData","rsEncoder","ReedSolomonEncoder","BinaryGF","BINARY_GF_6","message","version","size","imageData","EC_NONE","EC_LOW","EC_MEDIUM","EC_HIGH","Number","isInteger","ByteMatrix","BinaryGF_1","BinaryGFPoly_1","ReedSolomonEncoder_1","ReedSolomonDecoder_1","ReedSolomonDecoder","Writer_1","Writer","sumArray","arr","reduce","sum","utils_1","PatternLocator","locate","matrix","ratios","additionalChecks","startPoint","endPoint","startX","startY","endX","endY","locations","state","Uint16Array","stateIdx","isValidPattern","initialCenter","centerFromEnd","maxCount","vertical","calculatePatternMeasures","push","calculateLocationError","patternEnd","displacement","state_1","state_1_1","count","ratiosSum","unit","maxVariance","validPattern","abs","patternCenter","dx","dy","factor","SQRT2","SQRT5","checksCount","measures","averageSize","standardRatioError","centerError","patternSize","calculateStateError","sizeError","SIZE_ERROR_FACTOR","location","error","averageUnit","unitError","xEnd","yEnd","midStateIdx","sumForward","sumBackward","floor","sqDistance","distance","sqrt","vec","cross","eps","decoder_1","decode","encoder_1","binarizer_1","Decoder_1","extractor_1","locator_1","transform_1","decodeInternal","binarizedMatrix","FastAdaptiveBinarizer","binarize","patterns","Locator","transformedMatrix","CodeTransform","transform","extractedData","Extractor","extract","decodedData","Decoder","row","col","FastAdaptiveBinarizer_1","setPrototypeOf","__proto__","Array","constructor","BitMatrix_1","ByteMatrix_1","Binarizer_1","apply","arguments","BLOCK_SIZE","grayscaleMatrix","Binarizer","toGrayscale","T","calculateLocalMeanTable","minVariance","MIN_VARIANCE","constant","MEAN_CONST","binarized","blockSize","halfBlock","blockY","min","blockX","threshold","neighboursAvg","mat","rowSum","colSum","prev","red","green","blue","TO_GRAY","RED","GREEN","BLUE","Encoder_1","received","round","offset","dataLength","corrected","rsDecoder","alphabet","primitive","M_LIMIT","expTable","logTable","zeroPoly","onePoly","getSize","exp","log","getOnePoly","buildMonomial","coefficient","mulInverse","PRIMITIVE_DEGREE_6","generators","generator","getGenerator","remainderCoefficients","__read","return","receivedPoly","syndromes","computeSyndromes","_a","computeLocatorAndEvaluator","errorLocator","errorEvaluator","errorLocations","computeErrorLocations","errorMagnitudes","computeErrorMagnitudes","position","poly","R2","R1","A2","A1","Q","R0","A0","inverseConstant","errorCount","magnitudes","xiInverse","denominator","term","Extractor_1","writer_1","PatternLocator_1","imgWidth","imgHeight","scale","estimateScale","scaledUnitDim","UNIT_DIM","scaledSymbolDim","SYMBOL_DIM","scaledGapDim","GAP_DIM","scaledFinderRadius","FINDER_OUTER_RADIUS","cols","rows","baseDimension","estimateX1","estimateX2","estimateY1","estimateY2","scanY","horizontalShift","fixHorizontalShift","actualX1","actualX2","actualY2","endOfSymbol","oldState","LINE_STATE_INVALID","oldStateCount","oldStateStartY","bitsFound","mask","BITS_PER_SYMBOL","searchYLimit","newState","getHorizontalState","UNIT_DIM_THRESHOLD","GAP_DIM_THRESHOLD","scanFinderRadius","isValidFinderRadius","centre","baseDimensions","FINDER_INNER_RADIUS","FINDER_MIDDLE_RADIUS","x1","y1","x2","y2","VERTICAL_BORDER_BLACK_THRESHOLD","boxHeight","originalX1","originalX2","maxDiff","leftLimit","rightLimit","countBlackInLine","lineWidth","LINE_VALID_BLACK_THRESHOLD","zeroX1","BIT_ZERO_OFFSET","zeroX2","zeroWidth","LINE_ONE_BLACK_THRESHOLD","LINE_STATE_ZERO","LINE_STATE_ONE","FINDER_ERROR_THRESHOLD","resolution","roundEdges","inverted","render","code","codeSize","QUIET_ZONE","pad","drawFinderPattern","finderOffset","drawAlignmentPattern","drawSymbol","r1","r2","r3","fillCircle","err","fillSymmetricOctant","fillHorizontalLine","gridOffset","bitWidth","bitHeight","zeroOffset","BIT_ZERO_WIDTH","edgeRadius","bit","fillRect","Locator_1","geometry_1","e_1","compareError","patternLocator","finders","FINDER_RATIOS","sort","optimalFinders","findOptimalPatterns","estimatedFinderSize","assignFinders","finderAverageSize","bottomRight","topRight","topLeft","bottomLeft","alignmentSize","ALIGNMENT_TO_FINDER_RATIO","patternsDistance","f","alignments","ALIGNMENT_RATIOS","estimatedAlignmentSize","alignments_1","alignments_1_1","pattern","LOOSE_SIZE_TOLERANCE","CONFINED_SIZE_TOLERANCE","E","_","e_2","h","optimalFinders_1","optimalFinders_1_1","oldPattern","nearlySame","MIN_PATTERN_DIST","distinctPoint","u","estimatedSize","distAB","distAC","distBC","Uint8Array","CodeTranform_1","PerspectiveTransform_1","srcMatrix","dimension","transformer","PerspectiveTransform","distMatrix","srcPoint","TransformationMatrix_1","srcCorners","distCorners","quadrilateralToUnitSquareMatrix","times","unitSquareToQuadrilateralMatrix","dotColumn","x0","y0","x3","y3","adjugate","dx1","dx2","dx3","dy1","dy2","dy3","transformationMatrix","TransformationMatrix","a02","a12","A","Float32Array","val","dotRow","cofactor","cofactorMatrix","B","sign","k","transpose","transposed","result","C","options"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,YAAAH,GACA,iBAAAC,QACAA,QAAAI,OAAAL,IAEAD,EAAAM,OAAAL,IARA,CASCM,OAAA,WACD,gBAAAC,GCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAT,QAGA,IAAAC,EAAAM,EAAAE,IACAC,EAAAD,EACAE,KACAX,YAUA,OANAY,EAAAH,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAU,KAGAV,EAAAD,QA0DA,OArDAQ,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAhB,EAAAiB,EAAAC,GACAV,EAAAW,EAAAnB,EAAAiB,IACAG,OAAAC,eAAArB,EAAAiB,GAA0CK,cAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAxB,GACA,oBAAAyB,eAAAC,aACAN,OAAAC,eAAArB,EAAAyB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAArB,EAAA,cAAiD2B,YAQjDnB,EAAAF,EAAA,SAAAqB,EAAAC,GAEA,GADA,EAAAA,IAAAD,EAAAnB,EAAAmB,IACA,EAAAC,EAAA,OAAAD,EACA,KAAAC,GAAA,iBAAAD,QAAAE,WAAA,OAAAF,EACA,IAAAG,EAAAV,OAAAW,OAAA,MAGA,GAFAvB,EAAAgB,EAAAM,GACAV,OAAAC,eAAAS,EAAA,WAAyCR,cAAAK,UACzC,EAAAC,GAAA,iBAAAD,EAAA,QAAAK,KAAAL,EAAAnB,EAAAQ,EAAAc,EAAAE,EAAA,SAAAA,GAAgH,OAAAL,EAAAK,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAtB,EAAA0B,EAAA,SAAAjC,GACA,IAAAiB,EAAAjB,KAAA4B,WACA,WAA2B,OAAA5B,EAAAkC,SAC3B,WAAiC,OAAAlC,GAEjC,OADAO,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,IDxEA,ECwEA,SAAAnC,EAAAoC,EAAAlB,GAAA,iBAAAd,EAAAiC,WAAAC,UAAA,SAAAtC,GAAA,IAAAoC,EAAA,mBAAAjB,QAAAnB,EAAAmB,OAAAoB,UAAArB,EAAA,SAAAkB,IAAA7B,KAAAP,IAAAwC,KAAA,kBAAAxC,GAAAkB,GAAAlB,EAAAyC,SAAAzC,OAAA,IAAAqB,MAAArB,KAAAkB,KAAAwB,MAAA1C,MAAAc,OAAAC,eAAAqB,EAAA,cAAAf,OAAA,IC1EA,IAAAsB,EAAA,WAWI,SAAAA,EAAmBC,EAAiBC,GAChC,GAA4B,IAAxBA,EAAaJ,OACb,MAAM,IAAIK,MAAM,wBAGpBT,KAAKO,MAAQA,EAIb,IADA,IAAIG,EAAU,EACPA,EAAUF,EAAaJ,OAAS,GAA+B,IAA1BI,EAAaE,IACrDA,IAEJV,KAAKQ,aAAeA,EAAaG,MAAMD,GA4N/C,OApNWJ,EAAAX,UAAAiB,UAAP,WACI,OAAOZ,KAAKQ,aAAaJ,OAAS,GAQ/BE,EAAAX,UAAAkB,gBAAP,WACI,OAAOb,KAAKQ,cAUTF,EAAAX,UAAAmB,eAAP,SAAsBC,GAClB,GAAIA,EAAS,GAAKA,GAAUf,KAAKQ,aAAaJ,OAC1C,MAAM,IAAIK,MAAM,yDAGpB,OAAOT,KAAKQ,aAAaR,KAAKQ,aAAaJ,OAAS,EAAIW,IAWrDT,EAAAX,UAAAqB,WAAP,SAAkBC,WACd,GAAU,IAANA,EACA,OAAOjB,KAAKc,eAAe,GAG/B,IAAII,EAAM,MACV,IAAiB,IAAAC,EAAAlB,EAAAD,KAAKQ,cAAYY,EAAAD,EAAAhB,QAAAiB,EAAAf,KAAAe,EAAAD,EAAAhB,OAAE,CAA/B,IAAMkB,EAAED,EAAApC,MACTkC,EAAMlB,KAAKO,MAAMe,IAAID,EAAIrB,KAAKO,MAAMgB,SAASL,EAAKD,sGAGtD,OAAOC,GAWJZ,EAAAX,UAAA2B,IAAP,SAAWE,GACP,GAAIxB,KAAKO,QAAUiB,EAAMjB,MACrB,MAAM,IAAIE,MAAM,gDAGpB,GAAIT,KAAKyB,SACL,OAAOD,EAEX,GAAIA,EAAMC,SACN,OAAOzB,KAKX,IAFA,IAAM0B,EAAYC,KAAKC,IAAI5B,KAAKQ,aAAaJ,OAAQoB,EAAMhB,aAAaJ,QAClEyB,EAAkB,IAAIC,kBAAkBJ,GACrC3D,EAAI,EAAGA,EAAIiC,KAAKQ,aAAaJ,OAAQrC,IAC1C8D,EAAgB9D,EAAI2D,EAAY1B,KAAKQ,aAAaJ,QAAUJ,KAAKO,MAAMe,IACnEO,EAAgB9D,EAAI2D,EAAY1B,KAAKQ,aAAaJ,QAASJ,KAAKQ,aAAazC,IAGrF,IAASA,EAAI,EAAGA,EAAIyD,EAAMhB,aAAaJ,OAAQrC,IAC3C8D,EAAgB9D,EAAI2D,EAAYF,EAAMhB,aAAaJ,QAAUJ,KAAKO,MAAMe,IACpEO,EAAgB9D,EAAI2D,EAAYF,EAAMhB,aAAaJ,QAASoB,EAAMhB,aAAazC,IAIvF,OAAO,IAAIuC,EAAaN,KAAKO,MAAOsB,IAWjCvB,EAAAX,UAAAoC,aAAP,SAAoBP,GAChB,GAAIxB,KAAKO,QAAUiB,EAAMjB,MACrB,MAAM,IAAIE,MAAM,gDAGpB,GAAIT,KAAKyB,UAAYD,EAAMC,SACvB,OAAOzB,KAAKO,MAAMyB,cAEtB,GAAIhC,KAAKiC,QACL,OAAOT,EAEX,GAAIA,EAAMS,QACN,OAAOjC,KAKX,IAFA,IAAM0B,EAAY1B,KAAKQ,aAAaJ,OAASoB,EAAMhB,aAAaJ,OAAS,EACnEyB,EAAkB,IAAIC,kBAAkBJ,GACrC3D,EAAI,EAAGA,EAAIiC,KAAKQ,aAAaJ,OAAQrC,IAC1C,IAAK,IAAImE,EAAI,EAAGA,EAAIV,EAAMhB,aAAaJ,OAAQ8B,IAAK,CAChD,IAAMC,EAAInC,KAAKQ,aAAazC,GACtBqE,EAAIZ,EAAMhB,aAAa0B,GAC7BL,EAAgB9D,EAAImE,GAAKlC,KAAKO,MAAMe,IAChCO,EAAgB9D,EAAImE,GAAIlC,KAAKO,MAAMgB,SAASY,EAAGC,IAK3D,OAAO,IAAI9B,EAAaN,KAAKO,MAAOsB,IAUjCvB,EAAAX,UAAA0C,eAAP,SAAsBpB,GAClB,GAAU,IAANA,EACA,OAAOjB,KAAKO,MAAMyB,cAEtB,GAAU,IAANf,EACA,OAAOjB,KAIX,IADA,IAAM6B,EAAkB,IAAIC,kBAAkB9B,KAAKQ,aAAaJ,QACvDrC,EAAI,EAAGA,EAAIiC,KAAKQ,aAAaJ,OAAQrC,IAC1C8D,EAAgB9D,GAAKiC,KAAKO,MAAMgB,SAASvB,KAAKQ,aAAazC,GAAIkD,GAGnE,OAAO,IAAIX,EAAaN,KAAKO,MAAOsB,IAejCvB,EAAAX,UAAA2C,WAAP,SAAkBd,GACd,GAAIxB,KAAKO,QAAUiB,EAAMjB,MACrB,MAAM,IAAIE,MAAM,gDAEpB,GAAIe,EAAMC,SACN,MAAM,IAAIhB,MAAM,qBAMpB,GAAIT,KAAKyB,UAAYD,EAAMS,QACvB,OAAQjC,KAAMA,KAAKO,MAAMyB,eAK7B,IAFA,IAAMd,EAAM,IAAIY,kBAAkB9B,KAAKQ,cACjC+B,EAAaf,EAAMhB,aAAa,GAC7BzC,EAAI,EAAGA,EAAIiC,KAAKQ,aAAaJ,OAASoB,EAAMhB,aAAaJ,OAAS,EAAGrC,IAAK,CAC/EmD,EAAInD,GAAKiC,KAAKO,MAAMiC,OAAOtB,EAAInD,GAAIwE,GACnC,IAAME,EAAOvB,EAAInD,GACjB,GAAa,IAAT0E,EACA,IAAK,IAAIP,EAAI,EAAGA,EAAIV,EAAMhB,aAAaJ,OAAQ8B,IAC3ChB,EAAInD,EAAImE,GAAKlC,KAAKO,MAAMe,IACpBJ,EAAInD,EAAImE,GACRlC,KAAKO,MAAMgB,SAASkB,EAAMjB,EAAMhB,aAAa0B,KAM7D,IAAMQ,EAAkBlB,EAAMhB,aAAaJ,OAAS,EACpD,OACI,IAAIE,EAAaN,KAAKO,MAAOW,EAAIP,MAAM,GAAI+B,IAC3C,IAAIpC,EAAaN,KAAKO,MAAOW,EAAIP,OAAO+B,MASzCpC,EAAAX,UAAA8B,OAAP,WACI,OAAgC,IAAzBzB,KAAKQ,aAAa,IAQtBF,EAAAX,UAAAsC,MAAP,WACI,OAAoC,IAA7BjC,KAAKQ,aAAaJ,QAAyC,IAAzBJ,KAAKQ,aAAa,IAEnEF,EAnPA,GAAajD,EAAAiD,8aCRb,IAQAqC,EAAA,SAAAC,GAAA,SAAAD,mDA+BA,OA/B+BE,EAAAF,EAAAC,GACpBD,EAAAhD,UAAAmD,IAAP,SAAW7B,EAAW8B,EAAW/D,GAC7BgB,KAAKgD,KAAKD,EAAI/C,KAAKiD,MAAQhC,GAAe,IAAVjC,EAAc,EAAI,GAS/C2D,EAAAhD,UAAAuD,QAAP,WAKI,IAJA,IAAMD,EAAQjD,KAAKiD,MACbE,EAASnD,KAAKmD,OACdH,EAAO,IAAIlB,kBAAkB,EAAIqB,EAASF,GAC5CG,EAAc,EACTL,EAAI,EAAGA,EAAII,EAAQJ,IACxB,IAAK,IAAI9B,EAAI,EAAGA,EAAIgC,EAAOhC,IAAK,CAC5B,IAAIoC,EAAgB,IACG,IAAnBrD,KAAKpB,IAAIqC,EAAG8B,KACZM,EAAQ,GAEZL,EAAKI,GAAOC,EACZL,EAAKI,EAAM,GAAKC,EAChBL,EAAKI,EAAM,GAAKC,EAChBL,EAAKI,EAAM,GAAK,IAChBA,GAAO,EAGf,OAASH,MAAKA,EAAEE,OAAMA,EAAEH,KAAIA,IAEpCL,EA/BA,CARA9E,EAAA,GAQ+ByF,QAAlBjG,EAAAsF,2FCRb,IAAAY,EAAA1F,EAAA,GASA2F,EAAA,oBAAAA,KA8GA,OAxDWA,EAAA7D,UAAA8D,OAAP,SAAcC,EAAiBC,GAC3B,GAAuB,IAAnBD,EAAQtD,OACR,MAAM,IAAIK,MAAM,kBAEpB,GAAIkD,EAAU,GAAKA,EAAU,EACzB,MAAM,IAAIlD,MAAM,8DAIpB,IAAImD,EAAYjC,KAAKkC,KAAKH,EAAQtD,OAASuD,GAAWH,EAAQM,kBAGxDC,EAAcP,EAAQQ,OAASN,EAAQtD,OAASwD,EAEtD,GAAIG,EAAcP,EAAQS,SACtB,MAAM,IAAIxD,MAAM,8DAKpB,IADA,IAAIyD,EAAa,EACVA,EAAaA,EAAaH,GAC7BG,IAEJ,IAAMC,EAAWD,EAAaA,EAG9BN,GAAcO,EAAWJ,GAAe,EAGxC,IAAMf,EAA0B,IAAIlB,kBAAkBqC,EAAWP,GAE5DO,EAAWJ,EAAe,IAC3Bf,EAAKmB,EAAW,EAAIP,GAAa,GAErCZ,EAAK,GAAKQ,EAAQY,QAClBpB,EAAK,GAAKU,EAAQtD,OAClBsD,EAAUA,EAAQW,cAClB,IAAK,IAAItG,EAAI,EAAGA,EAAI2F,EAAQtD,OAAQrC,IAAK,CACrC,IAAMuG,EAAad,EAAQe,SAASC,QAAQd,EAAQ3F,IACpD,IAAoB,IAAhBuG,EACA,MAAM,IAAI7D,MAAM,iCAEpBuC,EAAKjF,EAAIyF,EAAQQ,QAAUM,EAI/B,IACIG,EADEC,EAAY,IAAInB,EAAAoB,mBAAmBpB,EAAAqB,SAASC,aAElD,IACIJ,EAAcC,EAAUjB,OAAOT,EAAMY,GACvC,MAAO7D,GACL,MAAM,IAAIU,MAAM,kCAAoCV,EAAE+E,QAAU,MAGpE,OAASC,QAAS/B,EAAK,GAAIgC,KAAMd,EAAYlB,KAAMyB,EAAaQ,UAAW,OAxGjEzB,EAAAY,QAAkB,EAIlBZ,EAAAS,SAAmB,GAInBT,EAAAQ,OAAiB,EAIjBR,EAAA0B,QAAkB,EAIlB1B,EAAA2B,OAAiB,IAIjB3B,EAAA4B,UAAoB,IAIpB5B,EAAA6B,QAAkB,IAIlB7B,EAAAM,kBAA4B,EAI5BN,EAAAe,SACV,mEAyERf,EA9GA,GAAanG,EAAAmG,yFCHb,IAAAF,EAAA,WAcI,SAAAA,EAAYL,EAAeE,GACvB,IAAKmC,OAAOC,UAAUtC,KAAWqC,OAAOC,UAAUpC,GAC9C,MAAM,IAAI1C,MAAM,wCAEpBT,KAAKiD,MAAQA,EACbjD,KAAKmD,OAASA,EACdnD,KAAKgD,KAAO,IAAIlB,kBAAkBmB,EAAQE,GAMlD,OAHWG,EAAA3D,UAAAf,IAAP,SAAWqC,EAAW8B,GAClB,OAAO/C,KAAKgD,KAAKD,EAAI/C,KAAKiD,MAAQhC,IAE1CqC,EA1BA,GAAsBjG,EAAAiG,waCNtB,IAQAkC,EAAA,SAAA5C,GAAA,SAAA4C,mDAIA,OAJgC3C,EAAA2C,EAAA5C,GACrB4C,EAAA7F,UAAAmD,IAAP,SAAW7B,EAAW8B,EAAW/D,GAC7BgB,KAAKgD,KAAKD,EAAI/C,KAAKiD,MAAQhC,GAAKjC,GAExCwG,EAJA,CARA3H,EAAA,GAQgCyF,QAAnBjG,EAAAmI,4FCRb,IAAAC,EAAA5H,EAAA,IAASR,EAAAuH,SAAAa,EAAAb,SACT,IAAAc,EAAA7H,EAAA,GAASR,EAAAiD,aAAAoF,EAAApF,aACT,IAAAqF,EAAA9H,EAAA,IAASR,EAAAsH,mBAAAgB,EAAAhB,mBACT,IAAAiB,EAAA/H,EAAA,IAASR,EAAAwI,mBAAAD,EAAAC,kGCHT,IAAAC,EAAAjI,EAAA,IAASR,EAAA0I,OAAAD,EAAAC,sFCOT1I,EAAA2I,SAAA,SAAyBC,GACrB,OAAQA,EAAYC,OAAO,SAACC,EAAalF,GAAc,OAAAkF,EAAMlF,sRCNjE,IAAAmF,EAAAvI,EAAA,GAgCAwI,EAAA,oBAAAA,KAkWC,OAnUUA,EAAA1G,UAAA2G,OAAP,SACIC,EACAC,EACAC,EACAC,EACAC,YAFAF,eAAA,IACAC,OAAsBzF,EAAG,EAAG8B,EAAG,aAC/B4D,OAAoB1F,EAAGsF,EAAOtD,MAAOF,EAAGwD,EAAOpD,SAE/CnD,KAAKuG,OAASA,EACdvG,KAAKwG,OAASA,EACdxG,KAAK4G,OAASF,EAAWzF,EACzBjB,KAAK6G,OAASH,EAAW3D,EACzB/C,KAAK8G,KAAOH,EAAS1F,EACrBjB,KAAK+G,KAAOJ,EAAS5D,EACrB/C,KAAKyG,iBAAmBA,EAUxB,IARA,IAAMO,KAGAC,EAAQ,IAAIC,YAAYV,EAAOpG,QACjC+G,EAAW,EAINpE,EAAI/C,KAAK6G,OAAQ9D,EAAI/C,KAAK+G,KAAMhE,GAAK,EAAG,CAC7C,IAAK,IAAI9B,EAAIjB,KAAK4G,OAAQ3F,EAAIjB,KAAK8G,OAAQ7F,EAAG,CAC1C,IAAgB,EAAXkG,KAAkBZ,EAAO3H,IAAIqC,EAAG8B,MAG/BoE,IACeX,EAAOpG,OAAQ,CAE5B,GAAIJ,KAAKoH,eAAeH,GAAQ,CAC5B,IAAMI,EAAuBrH,KAAKsH,eAAgBrG,EAAGA,EAAI,EAAG8B,EAACA,GAAIkE,GAC3DM,EAAWN,EAAMT,EAAOpG,QAAU,IAAM,EAGxCoH,EAAWxH,KAAKyH,yBAClBJ,EAAe,EAAG,EAAGE,QACJvH,KAAKoH,eAAeI,EAASP,QAI9CD,EAAUU,KAAK1H,KAAK2H,uBAChBN,EAAeE,IAM3B,IAAK,IAAIxJ,EAAI,EAAGA,EAAIkJ,EAAM7G,SAAUrC,EAChCkJ,EAAMlJ,EAAI,GAAKkJ,EAAMlJ,GAGzBkJ,EAAMT,EAAOpG,OAAS,GAAK6G,EAAMT,EAAOpG,OAAS,GAAK,EACtD+G,EAAWX,EAAOpG,OAAS,IAIjC6G,EAAME,GAKZ,GAAIA,IAAaX,EAAOpG,OAAS,GAAKJ,KAAKoH,eAAeH,GAChDI,EAAuBrH,KAAKsH,eAAgBrG,EAAGjB,KAAK8G,KAAO,EAAG/D,EAACA,GAAIkE,GACzED,EAAUU,KAAK1H,KAAK2H,uBAChBN,EAA2C,EAA5BJ,EAAMT,EAAOpG,QAAU,UAM1C,IADA+G,EAAW,EACFpJ,EAAI,EAAGA,EAAIyI,EAAOpG,SAAUrC,EACjCkJ,EAAMlJ,GAAK,EAKvB,OAAOiJ,GAYHX,EAAA1G,UAAA2H,cAAR,SAAsBM,EAAmBX,GAGrC,IAFA,IAAIE,EAAWF,EAAM7G,QAAU,EAC3ByH,EAAeZ,EAAME,IAAa,IAC7BA,EAAWF,EAAM7G,QACtByH,GAAgBZ,EAAME,GAE1B,OACIlG,EAAG2G,EAAW3G,EAAI4G,EAClB9E,EAAG6E,EAAW7E,IAadsD,EAAA1G,UAAAyH,eAAR,SAAuBH,WACfd,EAAM,MACV,IAAoB,IAAA2B,EAAA7H,EAAAgH,GAAKc,EAAAD,EAAA3H,QAAA4H,EAAA1H,KAAA0H,EAAAD,EAAA3H,OAAE,CAAtB,IAAM6H,EAAKD,EAAA/I,MACZ,GAAc,IAAVgJ,EAEA,SAEJ7B,GAAO6B,oGAEX,IAAMC,EAAY7B,EAAAJ,SAAShG,KAAKwG,QAGhC,GAAIL,EAAM8B,EACN,SAQJ,IALA,IAAMC,EAAO/B,EAAM8B,EAEbE,EAAcD,EAAO,EAEvBE,KACKrK,EAAI,EAAGA,EAAIiC,KAAKwG,OAAOpG,SAAUrC,EAClC4D,KAAK0G,IAAIpB,EAAMlJ,GAAKmK,EAAOlI,KAAKwG,OAAOzI,IAAMiC,KAAKwG,OAAOzI,GAAKoK,IAC9DC,MAGR,OAAOA,GAgBH/B,EAAA1G,UAAAgI,uBAAR,SAA+BW,EAAsBf,GAEjD,IAAMgB,GAAM,EAAG,EAAG,GAAI,EAAG,GAAI,GACvBC,GAAM,EAAG,EAAG,EAAG,EAAG,EAAG,GACrBC,GACF,EAAG,EAAGpC,EAAeqC,MAAOrC,EAAeqC,MAC3CrC,EAAesC,MAAOtC,EAAesC,OAErCC,EAAcL,EAAGnI,OAChBJ,KAAKyG,mBACNmC,GAAe,GAQnB,IALA,IAAMX,EAAY7B,EAAAJ,SAAShG,KAAKwG,QAC1BqC,KACFC,EAAc,EACdC,EAAqB,EACrBC,EAAc,EACTjL,EAAI,EAAGA,EAAI6K,IAAe7K,EAC/B8K,EAASnB,KACL1H,KAAKyH,yBAAyBa,EAAeC,EAAGxK,GAAIyK,EAAGzK,GAAIwJ,EAAWkB,EAAO1K,KAEjF+K,GAAgBD,EAAS9K,GAAGkL,YAAcR,EAAO1K,GAIjDgL,GAAsB/I,KAAKkJ,oBACvBL,EAAS9K,GAAGkJ,MAAO4B,EAAS9K,GAAGkL,YAAchB,GAEjDe,GAAeH,EAAS9K,GAAGiL,YAG/BF,GAAeF,EACfI,GAAeJ,EACfG,GAAsBH,EAAc5I,KAAKwG,OAAOpG,OAEhD,IAAI+I,EAAY,EAChB,IAASpL,EAAI,EAAGA,EAAI6K,IAAe7K,EAC/BoL,IAAc,EAAIN,EAAS9K,GAAGkL,YAAcH,IACvC,EAAID,EAAS9K,GAAGkL,YAAcH,GAgBvC,OAdAK,GAAaP,EAIbO,GAAa9C,EAAe+C,mBAWxBC,UALApI,EAAG4H,EAAS,GAAGQ,SAASpI,EACxB8B,EAAG8F,EAAS,GAAGQ,SAAStG,GAKxBuG,MAAOP,EAAqBC,EAAcG,EAC1CnE,KAAM8D,EACNC,mBAAkBA,EAClBC,YAAWA,EACXG,UAASA,EACTN,SAAQA,EACRP,cAAaA,IAgBbjC,EAAA1G,UAAAuJ,oBAAR,SAA4BjC,EAAoBsC,GAE5C,IADA,IAAID,EAAQ,EACHvL,EAAI,EAAGA,EAAIiC,KAAKwG,OAAOpG,SAAUrC,EAAG,CACzC,IAAMyL,EAAavC,EAAMlJ,GAAKwL,EAAcvJ,KAAKwG,OAAOzI,GAAM,EAC9DuL,GAASE,EAAYA,EAEzB,OAAOF,GAgBHjD,EAAA1G,UAAA8H,yBAAR,SACIa,EACAC,EACAC,EACAjB,GAEA,GAAW,IAAPgB,GAAmB,IAAPC,EACZ,MAAM,IAAI/H,MAAM,8GAKpB,IAAIwG,EAAI,IAAAC,YAAgBlH,KAAAwG,OAAApG,QACpBa,EAAIqH,EAAcrH,EAClB8B,EAAIuF,EAAcvF,EAClB0G,GAAe,IAARlB,GAAa,EAAIvI,KAAKuG,OAAOtD,MAClCyG,GAAc,IAAdlB,GAAmB,EAAAxI,KAAOuG,OAAUpD,OACtCwG,EAAW3J,KAAAwG,OAAYpG,QAAA,EAC3B+G,EAAAwC,IAEI1I,IAAKwI,GAAY1G,IAAM2G,IACnB,EAAAvC,KAAAnH,KAAAuG,OAAA3H,IAAAqC,EAAA8B,MAGAoE,IACInH,KAAAwG,OAAApG,UAOJ6G,EAAME,GAAAI,IAGVtG,GAAKsH,EACRxF,GAAAyF,EAGD,IAAAoB,EAAA3C,EAAA0C,OAEA1I,EAAIqH,EAAcrH,EAAIsH,EACtBxF,EAAIuF,EAAcvF,EAAIyF,EACtBiB,EAAc,IAAPlB,GAAY,EAAIvI,KAAKuG,OAAOtD,MACnCyG,EAAW,IAAXlB,GAAW,EAAYxI,KAAAuG,OAAApD,OACvBgE,EAAQwC,IACJ1I,IAAKwI,GAAY1G,IAAM2G,IACR,EAAXvC,KAAWnH,KAAAuG,OAAA3H,IAAAqC,EAAA8B,KAED,KADVoE,KAKAF,EAAME,GAAAI,IAGVtG,GAAKsH,EACRxF,GAAAyF,EAED,IAAIqB,EAAc5C,EAAK0C,GAAaC,EACpCZ,EAAe,EAAAY,EAAYC,EAQ9B,OANGb,MAMHK,UAHOpI,EAAGqH,EAAcrH,EAAIU,KAAKmI,OAAOF,EAAaC,GAAe,GAAKtB,EACpExF,EAAAuF,EAAAvF,EAAApB,KAAAmI,OAAAF,EAAAC,GAAA,GAAArB,GAELvB,QAAA+B,cAAAC,YAAA7C,EAAAJ,SAAAiB,KApVDZ,EAAAqC,MAAA,cAKArC,EAAAsC,MAAA,aAgVJtC,EAAA+C,kBAAC,GAAA/C,EAlWD,GAAAtG,EAAAsG,eAAA7H,GAAA,SAAAb,EAAAoC,EAAAlB,GAAA,aCvBAJ,OAAAC,eAAArB,EAAA,cAAA2B,WAYA3B,EAAA0M,oBAHoB5H,EAAEC,GACrB,OAAAD,EAAAlB,EAAAmB,EAAAnB,IAAAkB,EAAAlB,EAAAmB,EAAAnB,IAAAkB,EAAAY,EAAAX,EAAAW,IAAAZ,EAAAY,EAAAX,EAAAW,IAcD1F,EAAA2M,kBAHgB7H,EAAKC,GACpB,OAAAT,KAAAsI,MAAA9H,EAAAlB,EAAAmB,EAAAnB,IAAAkB,EAAAlB,EAAAmB,EAAAnB,IAAAkB,EAAAY,EAAAX,EAAAW,IAAAZ,EAAAY,EAAAX,EAAAW,KAcD1F,EAAA6M,aAHa/H,EAAGC,GACf,OAAAnB,EAAAmB,EAAAnB,EAAAkB,EAAAlB,EAAA8B,EAAAX,EAAAW,EAAAZ,EAAAY,IAcD1F,EAAA8M,eAHchI,EAAIC,GACjB,OAAAD,EAAAlB,EAAAmB,EAAAW,EAAAZ,EAAAY,EAAAX,EAAAnB,yBAamBkB,EAAGC,EAACgI,GACvB,OAAAzI,KAAA0G,IAAAlG,EAAAlB,EAAAmB,EAAAnB,GAAAmJ,GAAAzI,KAAA0G,IAAAlG,EAAAY,EAAAX,EAAAW,GAAAqH,iCCvED3L,OAAAC,eAAArB,EAAA,cAAwC2B,WAA/B,IAAAqL,EAAAxM,EAAM,IACfR,EAAAiN,OAAAD,EAAAC,OAAS,IAAAC,EAAA1M,EAAM,IAAAkC,EAAA0D,OAAAlE,EAAAkE,QAAA,SAAA9F,EAAAoC,EAAAlB,GAAA,aCDfJ,OAAAC,eAAArB,EAAA,cAAoD2B,WAEpD,IAAAwL,EAAA3M,EAAA,IACA4M,EAAA5M,EAAA,IACA6M,EAAA7M,EAAA,IACA8M,EAAA9M,EAAA,IAEA+M,EAAA/M,EAAA,aA2BUgN,EAAgB7H,EAAAC,EAAAE,GACtB,IAEM2H,OAFeN,EAAaO,uBAEdC,SAAUhI,EAAAC,EAAAE,GAGxB8H,OAFWN,EAAQO,SAED5E,OAAAwE,GAGlBK,OAFiBP,EAAGQ,eAEJC,UAAYP,EAAAG,GAG5BK,OAFgBZ,EAAUa,WAEZC,QAAUL,GAE9BM,OADoBhB,EAAQiB,SACLpB,OAASgB,GAGnC,OADGG,EAAOR,SAAYA,EACtBQ,EAlBDpO,EAAAiN,gBAdQtH,EAAAC,EAAAE,OAEH,OAAA0H,EAAA7H,EAAAC,EAAAE,SACGpD,OACI,IAAK4L,EAAI,EAAGvI,EAAM,EAAGuI,EAAQxI,EAAOwI,QAChC,IAAKC,EAAI,EAAGA,EAAM3I,EAAS2I,IAACxI,GAAA,EAC5BJ,EAAKI,GAAO,IAAIJ,EAAMI,GACtBJ,EAAKI,EAAM,GAAK,IAAMJ,EAAKI,EAAM,GACpCJ,EAAAI,EAAA,OAAAJ,EAAAI,EAAA,GAGR,OAAAyH,EAAA7H,EAAAC,EAAAE,mCC9BL1E,OAAAC,eAAArB,EAAA,cAAA2B,WAAS,IAAA6M,EAAAhO,EAAA,IAAAkC,EAAAgL,sBAAAhN,EAAAgN,uBAAA,SAAApN,EAAAoC,EAAAlB,GAAA,iBAAAd,EAAAwB,EAAAS,WAAA6C,YAAA9E,EAAA,SAAAJ,EAAAoC,GAAA,OAAAhC,EAAAU,OAAAqN,iBAAAC,wBAAAC,OAAA,SAAArO,EAAAoC,GAAApC,EAAAoO,UAAAhM,IAAA,SAAApC,EAAAoC,GAAA,QAAAlB,KAAAkB,IAAAH,eAAAf,KAAAlB,EAAAkB,GAAAkB,EAAAlB,MAAAlB,EAAAoC,IAAA,SAAApC,EAAAoC,GAAA,SAAAlB,IAAAmB,KAAAiM,YAAAtO,EAAAI,EAAAJ,EAAAoC,GAAApC,EAAAgC,UAAA,OAAAI,EAAAtB,OAAAW,OAAAW,IAAAlB,EAAAc,UAAAI,EAAAJ,UAAA,IAAAd,KCATJ,OAAAC,eAAArB,EAAA,cAAA2B,WAKA,IAAAkN,EAAArO,EAAA,GACAsO,EAAAtO,EAAA,GAEAuO,EAAAvO,EAAA,IAM2CkN,EAAA,SAASnI,gBAuInD,cAAAA,KAAAyJ,MAAArM,KAAAsM,YAAAtM,KAvI0C,OAA3C6C,EAAAkI,EAAAnI,KA2BuBjD,UAAaqL,SAAU,SAAEhI,EAAAC,EAAAE,MACpCH,EAAA5C,SAAgB6C,EAAAE,EAAA,EACnB,UAAA1C,MAAA,6BAEGwC,EAAM8H,EAAUwB,YAAuBpJ,EAAA4H,EAAAwB,WAC1C,UAAA9L,MAAA,2BAGD,IAAA+L,EAAAJ,EAAAK,UAAAC,YAAmD1J,EAAAC,EAAAE,GAE7CwJ,EAAA3M,KAAA4M,wBAAcJ,GACdK,EAAW9B,EAAsB+B,aACjCC,EAAShC,EAAOiC,WAChBC,EAAY,IAAAf,EAAAvJ,UAAsBM,EAAWE,GAC7C+J,EAAYnC,EAAewB,WACjCY,EAAgBD,GAAM,EAClBnK,EAAS,EAAAqK,SAAmBrK,EAAGI,IAAWJ,EAAA,CAE1CqK,EAASzL,KAAKC,IAAED,KAAM0L,IAAAtK,EAAAoK,EAAWhK,EAAO,GAAA+J,EAAA,SACpC,IAAAjM,EAAS,EAAAqM,SAAmBrM,EAAGgC,IAAWhC,EAAA,CAE1CqM,EAAW3L,KAAGC,IAAAD,KAAA0L,IAAepM,EAAIkM,EAAOlK,EAAA,GAAAiK,EAAA,KACxC,IAAI7J,EAAAmJ,EAAwB5N,IAAEqC,EAAA8B,GAE1BwK,EAASZ,EAAA/N,IAAS0O,EAAQF,MAC1BzL,KAAA0G,IAAAkF,EAAAlK,GAAAwJ,KAII5L,EAAM,GAAA8B,EAAA,OAEFyK,GAAgBhB,EAAa5N,IAAAqC,EAAA,EAAA8B,GAC7ByJ,EAAgB5N,IAAIqC,EAAC8B,EAAM,GAE3ByJ,EAAS5N,IAASqC,EAAG,EAAM8B,EAAG,IAAK,EACnCpB,KAAA0G,IAASkF,EAAGlK,GAAc1B,KAAA0G,IAAAmF,EAAAnK,KAC7BkK,EAAAC,QAIJD,EAAAlK,EAAA,EAAA0J,EAGLE,EAAAnK,IAAA7B,EAAgB8B,EAAIM,EAAMkK,EAAW,KACxCf,EAAA1J,IAAA7B,EAAA8B,EAAAwK,IAGR,OAAAN,KAWiBtN,UAAAiN,wBAA0B,SAAQa,OAChD,IAAMd,EAAA,IAAMR,EAAO3G,WAAgBiI,EAAOxK,MAACwK,EAAAtK,QACrCuK,EAAS,IAAGxG,YAAAuG,EAAAtK,QACZ+J,EAAWnC,EAAsBwB,WACjCQ,EAAShC,EAAsBiC,WAC/BlG,EAAO6F,EAAE1J,MAAMiK,EAAY,EAEjCnG,EAAA4F,EAAAxJ,OAAA+J,EAAA,EAGSnK,EAAI,EAACA,EAAM4J,EAACxJ,SAAGJ,MAChB,IAAA9B,EAAS,EAAAA,EAAOiM,IAAWjM,EAC9ByM,EAAA3K,IAAA0K,EAAA7O,IAAAqC,EAAA8B,GAIL,IAAA4K,EAAa,MACT5K,EAAM,EAAIA,EAAMmK,IAAInK,EACvB4K,GAAAD,EAAA3K,GAGD4J,EAAA7J,IAAI,EAAI,EAAG6K,GAAOT,KAAAH,GAClB,IAAAa,EAAUD,MACN5K,EAAS,EAAAA,EAAOgE,IAAQhE,EACxB4K,EAASC,EAAGF,EAAU3K,EAAA,GAAS2K,EAAG3K,EAASmK,EAAY,GACvDP,EAAA7J,IAAI,EAAGC,EAAA4K,GAAOT,KAAAH,GACjBa,EAAAD,MAIQ1M,EAAI,EAACA,EAAM6F,IAAM7F,EAAA,KAClB8B,EAAS,EAAAA,EAAO4J,EAACxJ,SAAQJ,EAC5B2K,EAAA3K,IAAA0K,EAAA7O,IAAAqC,EAAAiM,EAAA,EAAAnK,GAAA0K,EAAA7O,IAAAqC,EAAA,EAAA8B,GAIQ,IAAT4K,EAAS,EACL5K,EAAM,EAAIA,EAAMmK,IAAInK,EACvB4K,GAAAD,EAAA3K,GAII4K,IADLhB,EAAA7J,IAAI7B,EAAG,EAAA0M,GAAOT,KAAAH,GACda,EAAKD,EACD5K,EAAS,EAAAA,EAAOgE,IAAQhE,EACxB4K,EAASC,EAAGF,EAAU3K,EAAA,GAAS2K,EAAG3K,EAASmK,EAAY,GACvDP,EAAA7J,IAAI7B,EAAG8B,EAAA4K,GAAOT,KAAAH,GACjBa,EAAAD,EAGR,OAAAhB,GA/HD5B,EAAAiC,WAAA,EAIAjC,EAAA+B,aAAA,GA4HJ/B,EAAAwB,WAAC,GAvI0CxB,EAAA,CAA9BqB,EAAAK,mECdbhO,OAAAC,eAAArB,EAAA,cAA8C2B,WAE9C,IAAAmN,EAAAtO,EAAA,GAAA4O,EAAA,WAsCA,SAACA,KAAA,OAAA9O,EAhBa+O,YAAe,SAAO1J,EAAAC,EAAAE,OAC5B,IAAAqJ,EAAoB,IAAML,EAAO3G,WAAAvC,EAAAE,GACxBJ,EAAI,EAACA,EAAMI,IAASJ,MACrB,IAAA9B,EAAA,EAAAA,EAAAgC,IAAAhC,EAAA,CAEA,IAAMmC,EAAoB,GAAdL,EAAKE,EAAQhC,GACnB4M,EAAK7K,EAAGI,EAAQ,GAChB0K,EAAO9K,EAAKI,EAAO,GACzB2K,EAAA/K,EAAgBI,EAAK,GAAA5E,EAETsE,IAAA7B,EAAU8B,EAAA8K,EAAQpB,EAAKuB,QAAAC,IAC/BH,EAAOrB,EAAUuB,QAAQE,MAChCH,EAAAtB,EAAAuB,QAAAG,MAGR,OAAA3B,KA9BQwB,SACLC,IAAK,MACLC,MAAM,MACRC,KAAA,OA4BL1B,EAtCD,GAAA1M,EAAA0M,UAAAlN,GAAA,SAAA5B,EAAAoC,EAAAlB,GAAA,aCFAJ,OAAAC,eAAArB,EAAA,cAAqE2B,WACrE,IAAAuE,EAAA1F,EAA6C,GAG7CuQ,EAAAvQ,EAAA,GAMA6N,EAAA,WAsEA,SAACA,KAAA,OAAA/N,EA7DagC,UAAU2K,OAAS,SAAG+D,GAC5B,IAAMtJ,EAAOsJ,EAAW,GAEpBrJ,EAAOrD,KAAK2M,MAAA3M,KAAAsI,KAAAoE,EAAejO,YAC3B2E,IAAUqJ,EAAM5K,QAAAY,SAAwBY,MAAAqJ,EAAAjO,OAC3C,UAAAK,MAAA,wBAKD,IAAA8N,EAAAH,EAAkB5K,QAAAQ,OAEdwK,EAAUH,EAAU,MACL,IAAfG,GAAgBA,EAAAD,EAAwBF,EAAAjO,OAC3C,UAAAK,MAAA,wBAKD,IAEIgO,EAFJ7K,EAAAyK,EAAAjO,OAA4BmO,EAAAC,GAAA,KAGT,IAAf5K,EAAkB,CAClB,IAAA8K,EAAA,IAAAnL,EAAAsC,mBAAAtC,EAAAqB,SAAAC,iBAIC4J,EAAAC,EAAApE,OAAA+D,EAAAzK,SACG7D,GACH,UAAAU,MAAA,8BAGJgO,EAAAJ,EAAA1N,YAMG,IAAI5C,EAAA,EAAAA,EAAYwQ,EAAKxQ,OACjB0Q,EAAU1Q,KAAMsQ,EAAAtQ,GACnB,UAAA0C,MAAA,wBAKL,IAAIkO,EAAkBP,EAAG5K,QAAAe,SACzBb,EAAc,OACN3F,EAAA,EAAAA,EAAUyQ,EAAWzQ,IAAI,IACzB0Q,EAAUF,EAAMxQ,IAAA4Q,EAAAvO,OACnB,UAAAK,MAAA,wBAGJiD,GAAAiL,EAAAF,EAAAF,EAAAxQ,WAIGgH,QAAIA,EACJC,KAAMA,EACNhC,KAAAU,EACFuH,SAAA,OAETS,EAtED,GAAA3L,EAAA2L,QAAAlN,GAAA,SAAAb,EAAAoC,EAAAlB,GAAA,aCVAJ,OAAAC,eAAArB,EAAA,cAA8C2B,WAE9C,IAAA0G,EAAA7H,EAAA,GA6BI+G,EAAA,oBAQSA,EAASgK,EAAWzQ,MACrBA,EAAA,GAAMA,EAAIyG,EAAMiK,QACnB,UAAApO,MAAA,uCAGDT,KAAKgF,KAAA,GAAY7G,EACjB6B,KAAK4O,UAAWA,EAChB5O,KAAK8O,SAAW,IAAIhN,kBAAkB9B,KAAKgF,MAE3ChF,KAAA+O,SAAA,IAAAjN,kBAAiC9B,KAAAgF,UAEjC,IAAA/D,EAAK,EACIlD,EAAA,EAAAA,EAAWiC,KAAKgF,KAAAjH,IACrBiC,KAAK8O,SAAS/Q,GAAKkD,EACnBjB,KAAA+O,SAAA9N,GAAAlD,GAEAkD,IAAA,GAEKjB,KAAQgF,OACZ/D,GAAAjB,KAAA4O,WAIL5O,KAAKgP,SAAU,IAAItJ,EAAApF,aAAaN,KAAM,IAAI8B,mBAAoB,KACjE9B,KAAAiP,QAAA,IAAAvJ,EAAApF,aAAAN,KAAA,IAAA8B,mBAAA,KA2HJ,OAAAnE,EAnHOgC,UAAYuP,QAAK,WACpB,OAAAlP,KAAAgF,QASGrF,UAAYwP,IAAS,SAAGlO,GAC3B,OAAAjB,KAAA8O,SAAA7N,MASQtB,UAAQyP,IAAA,SAAAnO,MACH,IAANA,EACH,UAAAR,MAAA,2CAEJ,OAAAT,KAAA+O,SAAA9N,MAQGtB,UAAYqC,YAAS,WACxB,OAAAhC,KAAAgP,YAQGrP,UAAY0P,WAAQ,WACvB,OAAArP,KAAAiP,WAWOtP,UAAU2P,cAAE,SAAAvO,EAAAwO,MACZxO,EAAM,EACT,UAAAN,MAAA,yCAGD,IAAAD,EAAkB,IAAAsB,kBAAYf,EAAA,GAEjC,OADGP,EAAW,GAAA+O,EACd,IAAA7J,EAAApF,aAAAN,KAAAQ,MAUGb,UAAa2B,IAAA,SAAAL,EAAA8B,GAChB,OAAA9B,EAAA8B,KAUQpD,UAAU4B,SAAS,SAAAN,EAAA8B,UACpB,IAAA9B,GAAS,IAAA8B,EACZ,EAEJ/C,KAAA8O,UAAA9O,KAAA+O,SAAA9N,GAAAjB,KAAA+O,SAAAhM,KAAA/C,KAAAgF,KAAA,KAAArH,EAUQgC,UAAQ6P,WAAA,SAAAvO,MACH,IAANA,EACH,UAAAR,MAAA,oCAEJ,OAAAT,KAAA8O,SAAA9O,KAAAgF,KAAA,EAAAhF,KAAA+O,SAAA9N,OAWQtB,UAAQ6C,OAAA,SAAAvB,EAAA8B,MACH,IAANA,EACH,UAAAtC,MAAA,qBAEJ,OAAAT,KAAAuB,SAAAN,EAAAjB,KAAAwP,WAAAzM,KA1KD6B,EAAA6K,mBAAA,GAIA7K,EAAAC,YAAA,IAAAD,IAAA6K,mBAAA,GAuKJ7K,EAAAiK,QAAC,EAAAjK,EA3JG,GAAA7E,EAAA6E,SAAArF,GAAA,SAAA5B,EAAAoC,EAAAlB,GAAA,aC9BJJ,OAAAC,eAAArB,EAAA,cAA8C2B,WAE9C,IAAA0G,EAAA7H,EAAA,GAYI8G,EAAA,oBAMSA,EAAcpE,GACnBP,KAAKO,QACRP,KAAA0P,YAAAnP,EAAA8O,cAuDJ,OAAA1R,EA5CsBgC,UAAQ8D,OAAA,SAAAT,EAAAY,MACH,IAAhBZ,EAAA5C,OACH,UAAAK,MAAA,uBAIc,IAAXmD,EACH,WAAA9B,kBAAAkB,GAKD,IAAA2M,EAAA3P,KAAA4P,aAA4BhM,GAE5Ba,EAAgB,IAAM3C,kBAAAkB,EAAA5C,OAAAwD,GACtBa,EAAM3B,IAAAE,GAEN,IAIA6M,EAJA,IAAAnK,EAAApF,aAAAN,KAAAO,MAAAkE,GAE8BnC,WAAcqN,GAAe,GAE3D9O,kBAGH,OADG4D,EAAO3B,IAAA+M,EAAYpL,EAAArE,OAAAyP,EAAAzP,QACtBqE,KAWgB9E,UAAKiQ,aAAoB,SAAY7O,OAC9C,IAAK1C,EAAA2B,KAAA0P,WAAoBtP,OAAC/B,GAAY0C,EAAM1C,IAK/C2B,KAAA0P,WAAAhI,KAAA1H,KAAA0P,WAAArR,EAAA,GAAA0D,aAAA,IAAA2D,EAAApF,aAAAN,KAAAO,MAAA,IAAAuB,mBAAA,EAAA9B,KAAAO,MAAA4O,IAAA9Q,EAAA,QAEJ,OAAA2B,KAAA0P,WAAA3O,IACJ4D,EA/DG,GAAA5E,EAAA4E,mBAAApF,GAAA,SAAA5B,EAAAoC,EAAAlB,GAAA,iBAAAd,EAAAiC,WAAA8P,QAAA,SAAAnS,EAAAoC,GAAA,IAAAlB,EAAA,mBAAAC,QAAAnB,EAAAmB,OAAAoB,UAAA,IAAArB,EAAA,OAAAlB,EAAA,IAAAI,EAAAwB,EAAAf,EAAAK,EAAAX,KAAAP,GAAAwE,KAAA,mBAAApC,QAAA,MAAAhC,EAAAS,EAAA2B,QAAAE,MAAA8B,EAAAuF,KAAA3J,EAAAiB,OAAA,MAAArB,GAAA4B,GAAA+J,MAAA3L,GAAA,YAAAI,MAAAsC,OAAAxB,EAAAL,EAAAuR,SAAAlR,EAAAX,KAAAM,GAAA,WAAAe,EAAA,MAAAA,EAAA+J,OAAA,OAAAnH,GCdJ1D,OAAAC,eAAArB,EAAA,cAA8C2B,WAE9C,IAAA0G,EAAA7H,EAAA,GAWIgI,EAAA,oBAMSA,EAActF,GACtBP,KAAAO,QAiKJ,OAAA5C,EAtJOgC,UAAA2K,OAAA,SAA2C+D,EAAAzK,GAG3C,IAAAoM,EAAA,IAAAtK,EAAApF,aAAAN,KAAAO,MAAA8N,GAEI4B,EAAUjQ,KAAMkQ,iBAAIF,EAAApM,MACpBqM,EAAOxO,SACV,WAAAK,kBAAAuM,OAOD,IAAA8B,EAAAL,EAAA9P,KAAAoQ,2BAAAH,EAAoDrM,GAAA,GAAAyM,EAAAF,EAAA,GAAAG,EAAAH,EAAA,GAE9CI,EAAevQ,KAAOwQ,sBAACH,GAE7BI,EAAsBzQ,KAAA0Q,uBAAAJ,EAAAC,GAEtB9B,EAAgB,IAAI3M,kBAAeuM,GACzBtQ,EAAA,EAAQA,EAAGwS,EAAgBnQ,OAAOrC,IAAK,CAC7C,IAAA4S,EAAAlC,EAAgBrO,OAAA,EAAAJ,KAAAO,MAAA6O,IAAAmB,EAAAxS,OAEZ4S,EAAU,EACb,UAAAlQ,MAAA,0BAGJgO,EAAAkC,GAAA3Q,KAAAO,MAAAe,IAAAmN,EAAAkC,GAAAF,EAAA1S,IAGJ,OAAA0Q,KAWS9O,UAAmBuQ,iBAAkB,SAAWU,EAAAhN,OACtD,IAAApD,EAAiB,IAAGsB,kBAAgB8B,GAChC7F,EAAA,EAAYA,EAAC6F,EAAa7F,IAC7ByC,EAAAoD,EAAA,EAAA7F,GAAA6S,EAAA5P,WAAAhB,KAAAO,MAAA4O,IAAApR,IAEJ,WAAA2H,EAAApF,aAAAN,KAAAO,MAAAC,MAciBb,UAAMyQ,2BAA4B,SAAAH,EAAArM,OAChD,IAAIiN,EAAK7Q,KAAAO,MAAU+O,cAAA1L,EAAA,GACfkN,EAAKb,EACLc,EAAK/Q,KAAKO,MAAMyB,cAEpBgP,EAAShR,KAACO,MAAS8O,aACfyB,EAAOlQ,aAAgBgD,EAAQ,IAC/B,IAAMqN,EAAEJ,EAAKvO,WAAOwO,GAAA,GACdI,EAAKL,EAAGvP,IAAI2P,EAAElP,aAAa+O,IAE/BK,EAAMJ,EAAAzP,IAAA2P,EAAAlP,aAAAiP,IACRH,EAAKC,EACLA,EAAKI,EACLH,EAAKC,EACRA,EAAAG,EAGD,IAAMpE,EAAAiE,EAAAlQ,eAA6B,GAC7BsQ,EAAkBpR,KAAAO,MAAAiP,WAAezC,GAI1C,OAHuBiE,EAAG3O,eAAG+O,GAENN,EAAEzO,eAAgB+O,OAatBzR,UAAG6Q,sBAAyB,SAAAH,OAC5C,IAAMgB,EAAYhB,EAAGzP,YAErBoG,KAEAjH,EAAK,EACGhC,EAAA,EAAAA,EAAYiC,KAACO,MAAU2O,UAAWnR,IAC9B,IAAJsS,EAAIrP,WAAAjD,KACJgC,IACHiH,EAAAU,KAAA1H,KAAAO,MAAAiP,WAAAzR,QAKDgC,IAAMsR,EACT,UAAA5Q,MAAA,wDAGJ,WAAAqB,kBAAAkF,MAcmBrH,UAAG+Q,uBAAsB,SAAAJ,EAAAC,OACzC,IAAMc,EAAad,EAAInQ,OAEvBkR,EAAiB,IAAGxP,kBAAiBuP,GAC3BtT,EAAA,EAAAA,EAAYsT,EAAWtT,IAAA,KAC7B,IAAIwT,EAAWvR,KAAKO,MAAAiP,WAAAe,EAAAxS,IAEpByT,EAAiB,EACRtP,EAAA,EAAMA,EAAEmP,EAAAnP,OACTnE,IAAAmE,GAIJ,IAAAuP,EAAWzR,KAAGO,MAAKe,IAAM,EAAAtB,KAASO,MAAAgB,SAAagQ,EAAMhB,EAAArO,KACxDsP,EAAAxR,KAAAO,MAAAgB,SAAAiQ,EAAAC,GAKJH,EAAAvT,GAAAiC,KAAAO,MAAAgB,SAAA+O,EAAAtP,WAAAuQ,GAAAvR,KAAAO,MAAAiP,WAAAgC,IAGJ,OAAAF,GACJzL,EAxKG,GAAA9F,EAAA8F,mBAAArH,GAAA,SAAAb,EAAAoC,EAAAlB,GAAA,aCdJJ,OAAAC,eAAArB,EAAA,cAAwC2B,WAA/B,IAAA0S,EAAA7T,EAAA,IAAAkC,EAAAwL,UAAAxN,EAAAwN,WAAA,SAAA5N,EAAAoC,EAAAlB,GAAA,aCCTJ,OAAAC,eAAArB,EAAA,cAAgD2B,WAChD,IAAAoP,EAAAvQ,EAAA,GAEA8T,EAAA9T,EAAA,GACAuI,EAAAvI,EAAA,GAEA+T,EAAA/T,EAAA,GAOA0N,EAAA,WA0eA,SAACA,KAAA,OAAA5N,EApbagC,UAAW6L,QAAO,SAAMjF,GAC9B,IAAMsL,EAAStL,EAAStD,MAExB6O,EAAAvL,EAAApD,OAEAnD,KAAI+R,MAAA/R,KAAagS,cAAGzL,GACpB,IAAI0L,GAAeN,EAAG5L,OAAAmM,SAAOlS,KAAa+R,OACtCI,EAAeR,EAAA5L,OAAOqM,WAAepS,KAAM+R,MAC3CM,EAAAV,EAAqB5L,OAAAuM,QAAOtS,KAAA+R,MAEhCQ,GAAAZ,EAAA5L,OAAAyM,oBAAiDxS,KAAA+R,OAE7CU,EAAC9Q,KAAA2M,OAAeuD,EAAAQ,EAAkBF,IAChCE,EAAYF,IACdO,EAAC/Q,KAAA2M,OAAewD,EAAeO,EAAGF,IAElCE,EAAeF,OACfM,IAAMC,EACT,UAAAjS,MAAA,iCAKD,IAAIkS,GAAiBD,EAAK,GAAGf,EAAa5L,OAAIqM,YAAiBM,EAAC,GAAAf,EAAA5L,OAAAuM,QAChEtS,KAAA+R,OAAaxL,EAAGtD,MAAAsD,EAAOpD,QAAWwP,EAAW,EAC7CV,EAAeN,EAAG5L,OAAAmM,SAAOlS,KAAa+R,MACtCI,EAAeR,EAAA5L,OAAOqM,WAAepS,KAAM+R,MAC3CM,EAAAV,EAAqB5L,OAAAuM,QAAOtS,KAAA+R,MAE5BQ,EAAiBZ,EAAA5L,OAAsByM,oBAASxS,KAAA+R,UAEhD,IAAA/O,EAAA,IAAAlB,kBAAA4Q,EAAkCD,GAE9B7G,EAAA,EAAAA,EAAA6G,EAAA7G,YAEIgH,EAAOjR,KAAA2M,MAAeiE,EACtB3G,GAAAuG,EAAwBE,IACxBQ,EAAalR,KAAK2M,MAAMsE,EAAAT,GACxBW,EAAanR,KAAK2M,MAAMiE,GAE5BQ,EAAgBpR,KAAK2M,MAAOwE,EAASX,GACjCxG,EAAA,EAAAA,EAAA+G,EAAA/G,IAAA,KAGA,IAAAqH,EAAArR,KAAAC,IAAA,EAAAD,KAAA2M,MAAAwE,EAAAb,IAIAgB,EAAAjT,KAAAkT,mBAAkC3M,EAAAqM,EAAAE,EAAAD,EAAAE,GAE5BI,EAAWF,EAAgB,GAC7BG,EAAWH,EAAW,GAG1BI,EAAAN,EAEIO,KACAC,EAAAhI,EAAkBiI,mBAClBC,EAAc,EAElBC,EAAAV,EAEIW,EAAS,EAEPC,GAAA,GAAYjC,EAAQ5L,OAAI8N,iBAAoB,EAElDC,EAAenS,KAAA0L,IAAY9G,EAAKpD,OAAWxB,KAAE2M,MAAAyE,EAAAV,IACzCW,EAAMc,IAAgBR,GAAmB,CACzC,IAAIS,EAAQ/T,KAAKgU,mBAAYzN,EAAc4M,EAAAC,EAAAJ,GACvCe,IAAaR,EAChBE,KAGGF,IAAahI,EAAGiI,oBACZC,EAAaxB,EAAU1G,EAAC0I,qBACpBN,GAAYhC,EAAA5L,OAAA8N,kBAIfD,KAAA,OAHGD,GAOJC,KAAW,EAACL,GAAAI,KAEZA,GAQJJ,EAAAQ,EACAN,EAAc,EACjBC,EAAAV,GAIDO,IAAahI,EAAGiI,oBACZC,EAAApB,EAAA9G,EAAwC2I,oBAEpCR,GAAY/R,KAAA2M,MAAAyE,EAAAd,IAIG,KAHf0B,GAIChS,KAAA2M,MAAAoF,EAAAzB,GAGDyB,EAAiBV,EAAC,EACtBS,EAAA,GAGCH,MAIRN,OAKGA,IAASc,EACbd,GAAArR,KAAA2M,MAAmB2D,GAGlBoB,EAAAK,EAIS,IAAN/H,GAAgB,IAANC,GAAMgI,IAAAxF,EAAwB5K,QAAAY,QAC3C,UAAA3D,MAAA,2BAIS,IAANkL,GAAgB,IAANC,GAAMgI,EAAAxF,EAAwB5K,QAAAQ,OAAA0O,EAAAD,EAC3C,UAAAhS,MAAA,wBAIDuC,EAAA2I,EAAA8G,EAAA7G,GAAAgI,EAEAhB,EAAaO,EACbN,EAAaO,EACbN,EAAanR,KAAK2M,MAAM+E,EAAUhB,GACrCU,EAAApR,KAAA2M,MAAAwE,EAAAX,GAIR,OAAAnP,KAUOrD,UAAQqS,cAAA,SAAAzL,GACZ,IAGAU,EAHId,EAAK,EACL6B,EAAM,KAIVf,EAAQjH,KAACmU,iBAAoB5N,GAAQtF,EAAA,EAAA8B,EAAA,QACjC/C,KAAGoU,oBAAsBnN,KACzBd,GAAOc,EAAC,GAAAA,EAAA,GAAAA,EAAA,GACXe,KAIDf,EAAQjH,KAACmU,iBAAoB5N,GAAQtF,EAAA,EAAA8B,EAAA,QACjC/C,KAAGoU,oBAAsBnN,KACzBd,GAAOc,EAAC,GAAAA,EAAA,GAAAA,EAAA,GACXe,KAIDf,EAAQjH,KAACmU,iBAAoB5N,GAAQtF,EAAA,EAAA8B,EAAA,QACjC/C,KAAGoU,oBAAsBnN,KACzBd,IAAQc,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAA2K,EAAAvL,eAAAqC,MACXV,KAIDf,EAAQjH,KAACmU,iBAAoB5N,GAAQtF,EAAA,EAAA8B,EAAAwD,EAAApD,OAAA,QACjCnD,KAAGoU,oBAAsBnN,KACzBd,GAAOc,EAAC,GAAAA,EAAA,GAAAA,EAAA,GACXe,KAIDf,EAAQjH,KAACmU,iBAAoB5N,GAAQtF,EAAA,EAAA8B,EAAAwD,EAAApD,OAAA,SACjCnD,KAAGoU,oBAAsBnN,KACzBd,GAAOc,EAAC,GAAAA,EAAA,GAAAA,EAAA,GACXe,KAIDf,EAAQjH,KAACmU,iBAAoB5N,GAAQtF,EAAA,EAAA8B,EAAAwD,EAAApD,OAAA,SACjCnD,KAAGoU,oBAAsBnN,KACzBd,IAAQc,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAA2K,EAAAvL,eAAAqC,MACXV,KAIDf,EAAQjH,KAACmU,iBAAoB5N,GAAQtF,EAAAsF,EAAAtD,MAAA,EAAAF,EAAA,SACjC/C,KAAGoU,oBAAsBnN,KACzBd,GAAOc,EAAC,GAAAA,EAAA,GAAAA,EAAA,GACXe,KAIDf,EAAQjH,KAACmU,iBAAoB5N,GAAQtF,EAAAsF,EAAAtD,MAAA,EAAAF,EAAA,QACjC/C,KAAGoU,oBAAsBnN,KACzBd,GAAOc,EAAC,GAAAA,EAAA,GAAAA,EAAA,GACXe,KAIDf,EAAQjH,KAACmU,iBAAoB5N,GAAQtF,EAAAsF,EAAAtD,MAAA,EAAAF,EAAA,SACjC/C,KAAGoU,oBAAsBnN,KACzBd,IAAQc,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAA2K,EAAAvL,eAAAqC,MACXV,KAGa,IAAVA,EACH,UAAAvH,MAAA,mCAMJ,OAH0B0F,EAAA6B,GAAaA,EAEd2J,EAAA5L,OAAAyM,uBAclB7S,UAAYwU,iBAAmB,SAAU5N,EAAQ8N,EAAM9L,EAAMC,MAC7D7G,KAAA0G,IAAME,GAAS,GAAC5G,KAAA0G,IAAAG,GAAA,GAA8B,IAA9BD,GAA8B,IAAAC,EACjD,UAAA/H,MAAA,kCAGD,IAAMwG,EAAQ,EACVe,GAAI,EAAQ,EAAC,GACb/G,EAAIoT,EAAOpT,EAEf8B,EAAAsR,EAAAtR,EAIK9B,GAAK,GAAKA,EAAGsF,EAAOtD,OAErBF,GAAA,GAAAA,EAAAwD,EAAApD,UAEY,EAAR8D,KAAQV,EAAA3H,IAAAqC,EAAA8B,IACXkE,IAES,IAANA,IAIJe,EAAKf,KACLhG,GAAKsH,EACRxF,GAAAyF,EAGJ,OAAAR,KAYOrI,UAAYyU,oBAAkB,SAAUpM,MAC3B,IAAbA,EAAA5H,QAAa,IAAA4H,EAAA,QAAAA,EAAA,QAAAA,EAAA,GAChB,iBAGGsM,GACA3C,EAAA5L,OAAOwO,oBACP5C,EAAA5L,OAAOyO,qBAAsB7C,EAAA5L,OAAOwO,oBACtC5C,EAAA5L,OAAAyM,oBAAAb,EAAA5L,OAAAyO,sBAEFjL,EAAAnD,EAAAJ,SAAAgC,GAAA5B,EAAAJ,SAAwDsO,GAGxDnM,EAAAoB,EAAA,EAEAnB,KAEQrK,EAAK,EAAGA,EAACuW,EAAWlU,SAAcrC,EAClC4D,KAAA0G,IAAAL,EAAejK,GAAKwL,EACtB+K,EAAAvW,IACEuW,EAAevW,GAAKoK,IACvBC,MAGR,OAAAA,KAgBSzI,UAAYuT,mBAAU,SAAA3M,EAAAkO,EAAgCC,EAAAC,EAAAC,OAC5D,IAAMrH,EAAYhC,EAAUsJ,gCACtBC,EAAQF,EAAOF,EAAM,EAErBK,GADAxO,EAAetD,MACFwR,GAEbO,EAAUL,EACVM,EAAStT,KAAG2M,OAAUqG,EAAEF,GAAA,GACxBS,EAAUvT,KAAOC,IAAI,EAACmT,EAAeE,GAE3CE,EAAAxT,KAAmB0L,IAAA9G,EAAAtD,MAAA,EAAA+R,EAAAC,GAGfR,EAAKS,GAELlV,KAAKoV,iBAAA7O,EAAAkO,EAAAC,EAAAD,EAAAG,GAAAE,EAAAvH,GACRkH,SAGGA,EAAKU,GAELnV,KAAKoV,iBAAA7O,EAAAkO,EAAAC,EAAAD,EAAAG,GAAAE,EAAAvH,GACRkH,SAKGE,EAAKQ,GAELnV,KAAKoV,iBAAA7O,EAAAoO,EAAAD,EAAAC,EAAAC,GAAAE,EAAAvH,GACRoH,SAGGA,EAAKO,GAELlV,KAAKoV,iBAAA7O,EAAAoO,EAAAD,EAAAC,EAAAC,GAAAE,EAAAvH,GACRoH,WAKGA,GAAAF,GAAQA,IAAUS,GAAcP,IAAAQ,GACnCJ,EAAAC,IAGJP,EAAAE,MAeShV,UAAOyV,iBAAe,SAAA7O,EAAAkO,EAAAC,EAAAC,EAAAC,MACxBH,IAAME,GAAID,IAAME,EACnB,UAAAnU,MAAA,4CAGD,IAAAuH,EAAU,EACD/G,EAAIwT,EAAIxT,GAAK0T,EAAI1T,QAClB,IAAK8B,EAAI2R,EAAA3R,GAAO6R,EAAK7R,IACxBiF,GAAAzB,EAAA3H,IAAAqC,EAAA8B,GAIR,OAAAiF,KAcSrI,UAAYqU,mBAAY,SAAAzN,EAAAkO,EAAAE,EAAA5R,GAC9B,IAAMsS,EAAYV,EAACF,EAAA,KAEnBzU,KAAAoV,iBAAA7O,EAAAkO,EAAA1R,EAAA4R,EAAA5R,GAEWsS,EAAU9J,EAAA+J,2BACpB,OAAA/J,EAAAiI,mBAKD,IAAM+B,EAAS5T,KAAKmI,MAAK2K,EAAK9C,EAAA5L,OAAOyP,gBAAkBxV,KAAK+R,OACtD0D,EAAS9T,KAAGkC,KAAM8Q,EAAGhD,EAAW5L,OAAAyP,gBAAAxV,KAAA+R,OAChC2D,EAAWD,EAAQF,EAAA,SACPvV,KAAAoV,iBAAsB7O,EAAAgP,EAAAxS,EAAA0S,EAA0B1S,GACvD2S,EAAUnK,EAAgBoK,yBACpCpK,EAAAqK,gBAIJrK,EAAAsK,gBApeDtK,EAAAuK,uBAAA,GAKAvK,EAAAsJ,gCAAA,IAKAtJ,EAAA+J,2BAAA,GAKA/J,EAAAoK,yBAAA,GAKApK,EAAA2I,kBAAA,IAMA3I,EAAA0I,mBAAA,GAIA1I,EAAAiI,oBAAA,EAIAjI,EAAAqK,gBAAA,EAmcJrK,EAAAsK,eAAC,EAAAtK,EA1eD,GAAAxL,EAAAwL,UAAAzL,GAAA,SAAAnC,EAAAoC,EAAAlB,GAAA,aCdAJ,OAAAC,eAAArB,EAAA,cAA4C2B,WAI5C,IAAAkN,EAAArO,EAAA,GAwDIkI,EAAA,oBAMSA,EAAAgQ,EAAaC,EAAWC,GAC7BjW,KAAK+V,WAAaA,EAClB/V,KAAKgW,WAAWA,EACnBhW,KAAAiW,WA8MJ,OAAAtY,EAnMOgC,UAAcuW,OAAQ,SAAKC,GAC3B,IAAAC,EAAAD,EAAAnR,OAEcoR,EAAArQ,EAAuBqM,YAAUgE,EAAgB,GAAArQ,EAAAuM,QAE/D,KAAAvM,EAAAyM,oBAAAzM,EAAAsQ,eAEArW,KAAI+R,MAAKpQ,KAASmI,MAAE9J,KAAA+V,WAAApD,GAChB3S,KAAA+R,MAAU,EACb,UAAAtR,MAAA,4BAKDT,KAAAuG,OAAA,IAAA2F,EAAqBvJ,UAAA3C,KAAA+V,WAAA/V,KAAA+V,YAGrB/V,KAAAsW,IAAA3U,KAAAmI,OAAA9J,KAAwB+V,WAAApD,EAAA3S,KAAA+R,OAAA,OAAAvT,GAETuH,EAAAsQ,WAAAtQ,EAAAyM,qBAAAxS,KAAA+R,MACV/R,KAAAsW,IACLtW,KAAKuW,mBAAoBtV,EAAGuV,EAAKzT,EAAUyT,IAC3CxW,KAAKuW,mBAAoBtV,EAAGjB,KAAA+V,WAAiBS,EAAezT,EAAGyT,IAE/DxW,KAAAuW,mBAAAtV,EAA0BuV,EAAAzT,EAAA/C,KAAA+V,WAAAS,IAK1BxW,KAAAyW,sBAAgBxV,EAAAjB,KAAA+V,WAAAS,EAAAzT,EAAA/C,KAAA+V,WAAAS,QAEZ,IAAKzY,EAAI,EAACA,EAAMqY,EAAIrY,QAChB,IAAKmE,EAAA,EAAAA,EAAWkU,EAAUlU,IAC7BlC,KAAA0W,WAAA3Y,EAAAmE,EAAAiU,EAAAnT,KAAAjF,EAAAqY,EAAAlU,OAKDlC,KAAKiW,aACIlY,EAAI,EAACA,EAAMiC,KAAI+V,WAAKhY,QAChBmE,EAAA,EAAOA,EAAIlC,KAAI+V,WAAW7T,IAClClC,KAAAuG,OAAAzD,IAAA/E,EAAAmE,EAAA,EAAAlC,KAAAuG,OAAA3H,IAAAb,EAAAmE,IAKZiU,EAAAlR,UAAAjF,KAAAuG,OAAArD,aAGGvD,UAAW4W,kBAAO,SAA2BlC,GAC7C,IAAMsC,EAAK5Q,EAAOwO,oBAAoBvU,KAAO+R,MACvC6E,EAAK7Q,EAAOyO,qBAAsBxU,KAAK+R,MAE7C8E,EAAA9Q,EAAAyM,oBAAoBxS,KAAA+R,MAGpB/R,KAAA8W,WAAAzC,EAAqBwC,EAAA,GAGrB7W,KAAA8W,WAAAzC,EAAsBuC,EAAA,GAEzB5W,KAAA8W,WAAAzC,EAAAsC,EAAA,IAAAhZ,EAGGgC,UAAW8W,qBAA0B,SAAQpC,GAC7C,IAAMsC,EAAK5Q,EAAOwO,oBAAoBvU,KAAO+R,MAE7C6E,EAAA7Q,EAAAyO,qBAAoBxU,KAAA+R,MAGpB/R,KAAA8W,WAAAzC,EAAsBuC,EAAA,GAEzB5W,KAAA8W,WAAAzC,EAAAsC,EAAA,IAAAhZ,EASIgC,UAAQmX,WAAS,SAAA1Y,EAAAS,EAAAwE,GAClBxE,EAAI8C,KAAK2M,MAAKzP,GAEdT,GAAK6C,EAAIU,KAAC2M,MAAAlQ,EAAA6C,GAAA8B,EAAApB,KAAA2M,MAAAlQ,EAAA2E,QACV,IAAI9B,EAAIpC,EACJkE,EAAE,EACFwF,EAAK,EAAE,EAAA1J,EACP2J,EAAG,EACPuO,EAAQ,EACJ9V,GAAK8B,GACL/C,KAAIgX,oBAAA5Y,EAAA6C,EAAA8B,EAAAM,GACJN,IACAgU,GAAOvO,EACPA,GAAK,EACD,EAAIuO,EAAAxO,EAAA,IACJtH,IACA8V,GAAOxO,EACVA,GAAA,IAAA5K,EASLgC,UAAKqX,oBAA8B,SAAU5Y,EAAG6C,EAAG8B,EAAAM,GACnDrD,KAAKiX,mBAAmB7Y,EAAE6C,EAAIA,EAAG7C,EAAE6C,EAAIA,EAAG7C,EAAE2E,EAAIA,EAAGM,GACnDrD,KAAKiX,mBAAmB7Y,EAAE6C,EAAIA,EAAG7C,EAAE6C,EAAIA,EAAG7C,EAAE2E,EAAIA,EAAGM,GACnDrD,KAAKiX,mBAAmB7Y,EAAE6C,EAAI8B,EAAG3E,EAAE6C,EAAI8B,EAAG3E,EAAE2E,EAAI9B,EAAGoC,GACtDrD,KAAAiX,mBAAA7Y,EAAA6C,EAAA8B,EAAA3E,EAAA6C,EAAA8B,EAAA3E,EAAA2E,EAAA9B,EAAAoC,MAMG1D,UAAasX,mBAAkB,SAAAxC,EAAAE,EAAA5R,EAAAM,OAC3B,IAAKtF,EAAA0W,EAAO1W,GAAK4W,EAAK5W,IACzBiC,KAAAuG,OAAAzD,IAAA/E,EAAAgF,EAAAM,MAID1D,UAAM+W,WAAoB,SAAU/K,EAAGC,EAAOgI,OAC9C,IAAMsD,EAAanR,EAAIsQ,WAAsC,EAA/BtQ,EAAayM,uBAC7B5G,GAAC7F,EAAAqM,WAAArM,EAAAuM,SAAA4E,GAAAlX,KAAA+R,MACT/R,KAAMsW,OACE3K,GAAC5F,EAAAqM,WAAArM,EAAAuM,SAAA4E,GAAAlX,KAAA+R,MACT/R,KAAAsW,IACAa,EAASpR,EAASqM,WAAYpS,KAAK+R,MACnCqF,EAAUrR,EAASmM,SAAClS,KAAe+R,MACnCsF,EAAYtR,EAAOyP,gBAAiBxV,KAAK+R,MACzC2D,EAAU3P,EAAGuR,eAAkBtX,KAAA+R,MAErCwF,EAAgBH,EAAY,EAAG,EAE3BI,EAAA,EAAAvW,EAAA2F,EAAA7D,EAAA8D,EAAA2Q,EAAAzR,EAAgD8N,gBAAA2D,IAAAzU,GAAA,EAAAqU,EAGhDpX,KAAIyX,SAAKxW,EAAAsW,EAAYxU,EAAAoU,EAAA,EAAAI,EAAAH,EAAA,GACjBpX,KAAAgW,YAEAhW,KAAK8W,YAAa7V,EAAGA,EAAIsW,EAAYxU,EAAGA,EAAIwU,GAAcA,EAAI,GAC9DvX,KAAA8W,YAAA7V,IAAsBsW,EAAAxU,IAAAwU,EAAA,GAAAA,EAAA,GAEtBvX,KAAK8W,YACC7V,EAAGA,EAAIkW,EAAWI,EAAYxU,EAAGA,EAAIwU,GAAcA,EAAI,GAEhEvX,KAAA8W,YAAA7V,IAAAkW,EAAAI,EAAAxU,IAAAwU,EAAA,GAAAA,EAAA,KAGGvX,KAAKyX,SAASxW,EAAC8B,EAAGwU,EAAWH,EAAa,GAC7CpX,KAAAyX,SAAAxW,EAAAkW,EAAAI,EAAAxU,EAAAwU,EAAAH,EAAA,IAIqB,IAAlBxD,EAAK,GAAS4D,KAGdxX,KAAIyX,SAAKxW,EAAAoW,EAAYE,EAAAxU,EAAA2S,EAAA,EAAA6B,EAAAH,EAAA,GACjBpX,KAAAgW,YAKAhW,KAAK8W,YACC7V,EAAGA,EAAIoW,EAAaE,EAAYxU,EAAGA,EAAIwU,GAAcA,EACvD,GAEJvX,KAAA8W,YAAA7V,IAAAoW,EAAAE,EAAuCxU,IAAAwU,EAAA,GAAAA,EAAA,GAKvCvX,KAAK8W,YACC7V,EAAGA,EAAIoW,EAAa3B,EAAY6B,EAAYxU,EAAGA,EAAIwU,GAAcA,EACnE,GAEPvX,KAAA8W,YAAA7V,IAAAoW,EAAA3B,EAAA6B,EAAAxU,IAAAwU,EAAA,GAAAA,EAAA,KAGGvX,KAAKyX,SAASxW,EAAIoW,EAAaE,EAAYxU,EAAEwU,EAAYH,EAAY,GACxEpX,KAAAyX,SAAAxW,EAAAoW,EAAA3B,EAAA3S,EAAAwU,EAAAH,EAAA,MAAAzZ,EAOTgC,UAAa8X,SAAO,SAAaxW,EAAA8B,EAAAE,EAAAE,EAAAE,OAC7B,IAAKtF,EAAI,EAACA,EAAMoF,EAAIpF,QAChB,IAAKmE,EAAA,EAAOA,EAAIe,EAAOf,IAC1BlC,KAAAuG,OAAAzD,IAAA7B,EAAAiB,EAAAa,EAAAhF,EAAAsF,IAjQT0C,EAAAmM,SAAA,EAIAnM,EAAA8N,gBAAA,EAIA9N,EAAAqM,YAAA,EAAArM,EAAA8N,gBAAA,GAAA9N,EAAAmM,SAKAnM,EAAAyP,gBAAA,IAAAzP,EAAAmM,SAIAnM,EAAAuR,eAAA,EAAAvR,EAAAmM,SAIAnM,EAAAuM,QAAA,EAAAvM,EAAAmM,SAIAnM,EAAAyM,oBAAA,GAAAzM,EAAAqM,WAIArM,EAAAyO,qBAAA,EAAAzO,EAAAyM,oBAAA,EAIAzM,EAAAwO,oBAAA,EAAAxO,EAAAyM,oBAAA,EAmOJzM,EAAAsQ,WAACtQ,EAAAqM,WAAArM,EAvNG,GAAAhG,EAAAgG,OAAAxG,GAAA,SAAA5B,EAAAoC,EAAAlB,GAAA,aC5DJJ,OAAAC,eAAArB,EAAA,cAAoC2B,WAA3B,IAAA0Y,EAAA7Z,EAAO,IAAAkC,EAAAmL,QAAAnN,EAAAmN,SAAA,SAAAvN,EAAAoC,EAAAlB,GAAA,iBAAAd,EAAAiC,WAAAC,UAAA,SAAAtC,GAAA,IAAAoC,EAAA,mBAAAjB,QAAAnB,EAAAmB,OAAAoB,UAAArB,EAAA,SAAAkB,IAAA7B,KAAAP,IAAAwC,KAAA,kBAAAxC,GAAAkB,GAAAlB,EAAAyC,SAAAzC,OAAA,IAAAqB,MAAArB,KAAAkB,KAAAwB,MAAA1C,MAAA4B,EAAAS,WAAA8P,QAAA,SAAAnS,EAAAoC,GAAA,IAAAlB,EAAA,mBAAAC,QAAAnB,EAAAmB,OAAAoB,UAAA,IAAArB,EAAA,OAAAlB,EAAA,IAAAI,EAAAwB,EAAAf,EAAAK,EAAAX,KAAAP,GAAAwE,KAAA,mBAAApC,QAAA,MAAAhC,EAAAS,EAAA2B,QAAAE,MAAA8B,EAAAuF,KAAA3J,EAAAiB,OAAA,MAAArB,GAAA4B,GAAA+J,MAAA3L,GAAA,YAAAI,MAAAsC,OAAAxB,EAAAL,EAAAuR,SAAAlR,EAAAX,KAAAM,GAAA,WAAAe,EAAA,MAAAA,EAAA+J,OAAA,OAAAnH,GCChB1D,OAAAC,eAAArB,EAAA,cAAqF2B,WAGrF,IAAA2Y,EAAA9Z,EAAA,GAEA+T,EAAA/T,EAAA,GAAAqN,EAAA,WAwNA,SAACA,KAAA,OAAAvN,EAAAgC,UAAA2G,OAAA,SAAAvG,GA9KO,IAAI6X,EAACzH,EACLnQ,KAAKuG,OAASA,EACdvG,KAAAgH,aAKA,IAAA6Q,EAAA,SAA0B1V,EAAAC,GAAA,OAAAD,EAAAmH,MAAAlH,EAAAkH,OAEpBwO,EAAU,IAAAlG,EAA2BvL,eAE3C0R,EAAAD,EAAAxR,OAAAtG,KAAAuG,OAAA2E,EAAA8M,eAGAD,EAAAE,KAAAJ,GAEA,IAAAK,EAAAlY,KAAAmY,oBAAAJ,GAMAK,EAAsBzW,KAAAC,IAAAsW,EAA2B,GAAElT,KAAAkT,EAAqB,GAAAlT,KAAAkT,EAAA,GAAAlT,MAExEkT,EAAKlY,KACDmY,oBAAkBJ,EAClBK,GAGJpY,KAAKqY,cAAUH,EAAiB,GAC5B7O,SAAA6O,EAAsB,GAAA7O,SAAA6O,EAAA,GAAA7O,eACtBrC,UAAAsR,mBAAsBJ,EAAA,GAAAlT,KACtBkT,EAAe,GAAGlT,KAGtBkT,EAAA,GAAAlT,MAAA,EAAAhF,KAEKgH,UAAOuR,aACRtX,EAAGjB,KAAKgH,UAAUwR,SAASvX,EAAIjB,KAAKgH,UAAUyR,QAAQxX,EAAIjB,KAAKgH,UAAU0R,WAAWzX,EACtF8B,EAAA/C,KAAAgH,UAAAwR,SAAAzV,EAAA/C,KAAAgH,UAAAyR,QAAA1V,EAAA/C,KAAAgH,UAAA0R,WAAA3V,QAEEiE,UAAK2R,cAET3Y,KAAAgH,UAAAsR,kBAAoCpN,EAAA0N,0BAEpC,IAAAC,EAAoBlB,EAAA3N,SAAShK,KAAKgH,UAAUyR,QAASzY,KAAKgH,UAAUwR,UACpEK,GAAmBlB,EAAW3N,SAAAhK,KAAAgH,UAAsByR,QAAAzY,KAAAgH,UAAA0R,YAEpDG,EAAAlX,KAAA2M,MAAAuK,EAAA,OAGInS,GACAzF,EAAGU,KAAKC,IAAI,EAAG5B,KAAKgH,UAAUuR,YAAYtX,EAAI6X,GAChD/V,EAAApB,KAAAC,IAAA,EAAA5B,KAAAgH,UAAAuR,YAAAxV,EAAA+V,IAIEnS,GACA1F,EAAGU,KAAK0L,IAAI9G,EAAOtD,MAAMjD,KAAMgH,UAAUuR,YAAYtX,EAAE6X,GACzD/V,EAAApB,KAAA0L,IAAA9G,EAAApD,OAAAnD,KAAAgH,UAAAuR,YAAAxV,EAAA+V,IAQIC,EAAAjB,EAAyBxR,OAAKtG,KAAUuG,OAAA2E,EAAc8N,oBAAAtS,EAAAC,GACxDsS,EAAuBjZ,KAAAgH,UAAA2R,iBACvBI,EAAA3Y,OAAA,GAAAP,EAAAoY,KAAAnY,GAAA,QAEK,IAAMoZ,EAAOjZ,EAAA8Y,GAAAI,EAAAD,EAAA/Y,QAAAgZ,EAAA9Y,KAAA8Y,EAAAD,EAAA/Y,OAAA,CACd,IAAAiZ,EAAAD,EAAAna,SAMIoa,EAAQpU,KAAOkG,EAAQmO,qBAAuBJ,GAE9CG,EAAKpU,KAAUkG,EAAAoO,wBAA+BL,EAAA,CAC9CjZ,KAAKgH,UAAUuR,YAAaa,EAAG/P,SAC/BrJ,KAAAgH,UAAM2R,cAAAS,EAAApU,KACT,cAAArH,GAAAkB,GAAAyK,MAAA3L,GAAA,YAAA4b,MAAAlZ,OAAAd,EAAAia,EAAAzJ,SAAAxQ,EAAArB,KAAAsb,GAAA,WAAA3a,EAAA,MAAAA,EAAAyK,QAKZ,OAAAtJ,KAAAgH,6DAeG,IAAMyS,EAAAtJ,EACN+H,KACIna,EAAA,EAAAA,EAAAga,EAAA3X,QAAA8X,EAAwC9X,OAAA,IAAArC,EAAA,KAAA2b,GAAA,UAEnC,IAAMC,EAAU1Z,EAAAiY,GAAA0B,EAAAD,EAAAxZ,QAAAyZ,EAAAvZ,KAAAuZ,EAAAD,EAAAxZ,OAAA,CACjB,IAAI0Z,EAAAD,EACU5a,SAIV2Y,EAAAmC,WAAsBD,EAAAxQ,SAAA0O,EAAAha,GAAAsL,SAAA6B,EAAA6O,kBAAA,CACtBC,KACH,cAAArc,GAAA4B,GAAA+J,MAAA3L,GAAA,YAAAsc,MAAA5Z,OAAA8B,EAAA/D,EAAA2R,SAAA5N,EAAAjE,KAAAE,GAAA,WAAAmB,EAAA,MAAAA,EAAA+J,OAGD0Q,KAMKE,KACDnc,GAAQiH,KAAOkG,EAAGmO,qBAAQa,GAE1BnC,EAAAha,GAAAiH,KAAAkG,EAAAoO,wBAA+CY,IAElDhC,EAAAxQ,KAAAqQ,EAAAha,OAILma,EAAe9X,OAAC,EACnB,UAAAK,MAAA,oCAGJ,OAAAyX,6CAYG,IAAA/H,EAAAhP,EAAAC,EAGM+Y,EAASxC,EAAA5N,WAAW5H,EAAGC,GACvBgY,EAASzC,EAAA5N,WAAW5H,EAAG/D,GAC7Bic,EAAA1C,EAAA5N,WAAA3H,EAAAhE,GAEIgc,EAAAD,GAAAC,EAACC,GACJjc,GAAA+R,EAAAL,GAAA1N,EAAAhE,GAAA,OAAAgE,EAAA+N,EAAA,IACGkK,EAAAF,IACH/b,GAAA+C,EAAA2O,GAAA3N,EAAA/D,GAAA,OAAA+D,EAAAhB,EAAA,IAMGwW,EAAAxN,MAAAwN,EAACzN,IAAA/H,EAAGC,GAAAuV,EAAYzN,IAAA/H,EAAA/D,IAAA,IACnB+D,GAAAf,EAAA0O,GAAA1N,EAAAD,GAAA,OAAAC,EAAAhB,EAAA,IAKDpB,KAAKgH,UAAU0R,WAAavW,EAC5BnC,KAAKgH,UAAUwR,SAAWpW,EAC7BpC,KAAAgH,UAAAyR,QAAAra,GAjND8M,EAAA6O,iBAAA,GAKA7O,EAAA0N,0BAAA,IAKA1N,EAAAmO,qBAAA,EAKAnO,EAAAoO,wBAAA,EAKApO,EAAA8M,cAAA,IAAAsC,YAAA,YA8LJpP,EAAA8N,iBAAC,IAAAsB,YAAA,QAAApP,EAxND,GAAAnL,EAAAmL,QAAApL,GAAA,SAAAnC,EAAAoC,EAAAlB,GAAA,aCNAJ,OAAAC,eAAArB,EAAA,cAA+C2B,WAAtC,IAAAub,EAAA1c,EAAA,IAAAkC,EAAAqL,cAAArN,EAAAqN,eAAA,SAAAzN,EAAAoC,EAAAlB,GAAA,aCATJ,OAAAC,eAAArB,EAAA,cAA4C2B,WAC5C,IAAAkN,EAAArO,EAAA,GAEA8Z,EAAA9Z,EAAA,GAEA2c,EAAA3c,EAAA,IAMAuN,EAAA,WA8CA,SAACA,KAAA,OAAAzN,EAnCOgC,UAAA0L,UAAA,SAAAoP,EAAAxP,WAIIyP,EAAA/Y,KAAA2M,OAASqJ,EAAS3N,SAASiB,EAASwN,QACpCxN,EAAGuN,UAEPb,EAAA3N,SAAAiB,EAAAwN,QAAAxN,EAAAyN,aAAA,GAKIiC,EAAc,IAAIH,EAAQI,uBACxB3Z,EAAGyZ,EAAS,EAAA3X,EAAA,IACZ9B,EAAG,EAAG8B,EAAG,IACT9B,EAAG,EAAA8B,EAAA2X,EAAkB,IACxBzZ,EAAAyZ,EAAA,EAAA3X,EAAA2X,EAAA,KAECzP,EAASuN,SACTvN,EAASwN,QACTxN,EAASyN,WACVzN,EAAAsN,cAGHsC,EAAiB,IAAG3O,EAAavJ,UAAG+X,KAC3BzZ,EAAI,EAACA,EAAMyZ,IAAazZ,MACzB,IAAI8B,EAAA,EAAQA,EAAG2X,IAAY3X,EAAA,CAC3B,IAAA+X,EAAcH,EAAatP,WAAWpK,EAAGA,EAAE8B,EAAKA,IAChD+X,GAAA7Z,EAAAU,KAAA2M,MAAAwM,EAAA7Z,GAAA8B,EAAApB,KAAA2M,MAAAwM,EAAA/X,IAEH8X,EAAA/X,IAAA7B,EAAA8B,EAAA0X,EAAA7b,IAAAkc,EAAA7Z,EAAA6Z,EAAA/X,IAIR,OAAA8X,GACJzP,EA9CD,GAAArL,EAAAqL,cAAAjJ,GAAA,SAAAxE,EAAAoC,EAAAlB,GAAA,aCNAJ,OAAAC,eAAArB,EAAA,cAAA2B,WAEA,IAAA+b,EAAAld,EAAA,IAQI+c,EAAA,oBAQQA,EAAsBI,EAAKC,MACX,IAAhBD,EAAU5a,QAAM,IAAA6a,EAAA7a,OACnB,UAAAK,MAAA,qEAeJT,KAAAyN,IAAAzN,KAAAkb,gCAAAF,EAAA,GAAA/Z,EAAA+Z,EAAA,GAAAjY,EAAAiY,EAAA,GAAA/Z,EAAA+Z,EAAA,GAAAjY,EAAAiY,EAAA,GAAA/Z,EAAA+Z,EAAA,GAAAjY,EAAAiY,EAAA,GAAA/Z,EAAA+Z,EAAA,GAAAjY,GAAAoY,MAAAnb,KAAAob,gCAAAH,EAAA,GAAAha,EAAAga,EAAA,GAAAlY,EAAAkY,EAAA,GAAAha,EAAAga,EAAA,GAAAlY,EAAAkY,EAAA,GAAAha,EAAAga,EAAA,GAAAlY,EAAAkY,EAAA,GAAAha,EAAAga,EAAA,GAAAlY,IAkFJ,OAAApF,EAxEwBgC,UAAY0L,UAAW,SAAWyP,GACnD,IAAAtJ,EAAOxR,KAAAyN,IAAA4N,UAAA,GAAAP,EAAA7Z,EAAA6Z,EAAA/X,EAAA,WAEH9B,EAAGjB,KAAKyN,IAAI4N,UAAU,GAAIP,EAAS7Z,EAAG6Z,EAAS/X,EAAG,IAAMyO,EAC1DzO,EAAA/C,KAAAyN,IAAA4N,UAAA,GAAAP,EAAA7Z,EAAA6Z,EAAA/X,EAAA,IAAAyO,MAmBF7R,UAAAub,gCAAA,SAAAI,EAAAC,EAA8E9G,EAAAC,EAAAC,EAAAC,EAAA4G,EAAAC,GAIjF,OAAAzb,KAAAob,gCAAAE,EAAAC,EAAA9G,EAAAC,EAAAC,EAAAC,EAAA4G,EAAAC,GAAAC,cAiBG/b,UAAAyb,gCAAiD,SAAAE,EAAAC,EAAA9G,EAAAC,EAAAC,EAAAC,EAAA4G,EAAAC,GAGjD,IAAME,EAAMlH,EAAKE,EACXiH,EAAMJ,EAAK7G,EACXkH,EAAMP,EAAK7G,EAAGE,EAAA6G,EACdM,EAAMpH,EAAKE,EACXmH,EAAMN,EAAK7G,EAEXoH,EAAAT,EAAW7G,EAAGE,EAAM6G,EACpBjK,EAAAmK,EAAoBI,EAAGH,EAAIE,EACjCG,EAAA,IAAAlB,EAAAmB,qBAGMC,GAAON,EAAME,EAAMH,EAAMI,GAAOxK,EAEtC4K,GAAAT,EAAAK,EAAqBH,EAAQC,GAAOtK,EAWvC,OAVGyK,EAAqBnZ,IAAI,EAAG,EAAG2R,EAAK6G,EAAKa,EAAM1H,GAC/CwH,EAAqBnZ,IAAI,EAAG,EAAG0Y,EAAIF,EAAAc,EAAAZ,GACnCS,EAAqBnZ,IAAI,EAAG,EAAGwY,GAC/BW,EAAqBnZ,IAAI,EAAG,EAAG4R,EAAK6G,EAAKY,EAAMzH,GAC/CuH,EAAqBnZ,IAAI,EAAG,EAAG2Y,EAAIF,EAAAa,EAAAX,GACnCQ,EAAqBnZ,IAAI,EAAG,EAAGyY,GAC/BU,EAAqBnZ,IAAI,EAAG,EAAGqZ,GAC/BF,EAAqBnZ,IAAI,EAAG,EAAGsZ,GAE/BH,EAAOnZ,IAAA,EAAqB,KAC/BmZ,GACJrB,EA3GG,GAAA7a,EAAA6a,qBAAArb,GAAA,SAAA5B,EAAAoC,EAAAlB,GAAA,aCfJJ,OAAAC,eAAArB,EAAA,cAAA2B,WAAA,IAMIkd,EAAyC,oBAChCA,EAAO1a,GACZxB,KAAKqc,SACD,IAAKte,EAAE,EAAKA,EAAI,IAAAA,EACnBiC,KAAAqc,EAAA3U,KAAA,IAAA4U,aAAA,OAEa,OAAV9a,YAAiBA,MACRzD,EAAI,EAACA,EAAM,IAAKA,MACjB,IAAKmE,EAAI,EAAGA,EAAG,IAAMA,EACxBlC,KAAAqc,EAAAte,GAAAmE,GAAAV,EAAA6a,EAAAte,GAAAmE,GAiIhB,OAAAvE,EA3HwBgC,UAAGf,IAAA,SAAAqC,EAAA8B,GACvB,OAAA/C,KAAAqc,EAAApb,GAAA8B,MAGkBpD,UAAImD,IAAA,SAAA7B,EAAA8B,EAAAwZ,GACtBvc,KAAAqc,EAAApb,GAAA8B,GAAAwZ,KAWmB5c,UAAQ6c,OAAA,SAAA7Q,EAAAnK,MACJ,IAAhBA,EAAMpB,OACT,UAAAK,MAAA,2CAEJ,OAAAT,KAAAqc,EAAA1Q,GAAA,GAAAnK,EAAA,GAAAxB,KAAAqc,EAAA1Q,GAAA,GAAAnK,EAAA,GAAAxB,KAAAqc,EAAA1Q,GAAA,GAAAnK,EAAA,IAAA7D,EAWmBgC,UAAQ0b,UAAA,SAAAzP,EAAApK,MACJ,IAAhBA,EAAMpB,OACT,UAAAK,MAAA,2CAEJ,OAAAT,KAAAqc,EAAA,GAAAzQ,GAAApK,EAAA,GAAAxB,KAAAqc,EAAA,GAAAzQ,GAAApK,EAAA,GAAAxB,KAAAqc,EAAA,GAAAzQ,GAAApK,EAAA,IAAA7D,EAUSgC,UAAqB8c,SAAA,eAC3B,IAAMC,EAAI,IAAiBR,EACrBS,EAAID,EAAOL,EACjBA,EAAKrc,KAAQqc,EACJte,EAAI,EAAC6e,EAAO,EAAI7e,EAAK,IAAEA,MACxB,IAAMmE,EAAI,EAAaA,EAAG,IAAAA,EAAA0a,IAAA,OAC1B,IAAMlK,KACND,KACIoK,EAAA,EAAAA,EAAA,IAAAA,EAEIA,IAAK9e,GACR2U,EAAAhL,KAAAmV,GAEGA,IAAK3a,GACRuQ,EAAA/K,KAAAmV,QAKA3a,GAAK0a,GAAKP,EAAK3J,EAAG,IAAKD,EAAM,IAAG4J,EAAK3J,EACxC,IAAAD,EAAA,IACL4J,EAAA3J,EAAA,IAAAD,EAAA,IAAA4J,EAAA3J,EAAA,IAAAD,EAAA,KAGR,OAAAiK,KASsB/c,UAAImd,UAAA,eACvB,IAAMC,EAAI,IAAab,EACjBS,EAAII,EAAOV,EACjBA,EAAKrc,KAAQqc,EACJte,EAAI,EAACA,EAAM,IAAKA,MAChB,IAAImE,EAAE,EAAKA,EAAI,IAAEA,EACrBya,EAAAza,GAAAnE,GAAAse,EAAAte,GAAAmE,GAGR,OAAA6a,KAUepd,UAAW+b,SAAY,WACtC,OAAA1b,KAAAyc,WAAAK,eAUsBnd,UAAAwb,MAAA,SAAuB3Z,OAC1C,IAAMwb,EAAI,IAASd,EACbe,EAAID,EAAOX,EACXM,EAAInb,EAAM6a,EAChBA,EAAKrc,KAAQqc,EACJte,EAAI,EAACA,EAAM,IAAKA,MAChB,IAAImE,EAAE,EAAKA,EAAA,IAAAA,EAAA,CACZ+a,EAAAlf,GAAKmE,GAAK,MACL,IAAI2a,EAAE,EAAKA,EAAI,IAAKA,EACxBI,EAAAlf,GAAAmE,IAAAma,EAAAte,GAAA8e,GAAAF,EAAAE,GAAA3a,GAIZ,OAAA8a,GAEJd,EA1I4C,GAAAnc,EAAAmc,qBAAAne,GAAA,SAAAJ,EAAAoC,EAAAlB,GAAA,aCL7CJ,OAAAC,eAAArB,EAAA,cAAoC2B,WACpC,IAAAoP,EAAAvQ,EAAA,GA8BA8T,EAAA9T,EAAA,GAAAkC,EAAA0D,OAAA,SAScC,EAAWwZ,aACrBA,EAAIA,OACQvZ,SAA4B,OAAlBuZ,EAAQvZ,UAC7BuZ,EAAAvZ,QAAAyK,EAAA5K,QAAA4B,oBAGG8X,EAAQnH,YAAkB,OAAAmH,EAAAnH,aAC7BmH,EAAAnH,WAAA,eAGGmH,EAAQlH,YAAmB,OAAAkH,EAAAlH,aAC9BkH,EAAAlH,oBAAA,IAGGkH,EAAQjH,UAAiB,OAAAiH,EAAAjH,WAC5BiH,EAAAjH,aAGD,IAEMxR,OAFc2J,EAAQ5K,SAETC,OAAOC,EAAQwZ,EAAAvZ,SAIrC,OAHgB,IAACgO,EAAY5L,OAACmX,EAAAnH,WAAAmH,EAAAlH,WAAAkH,EAAAjH,UAEpBC,OAAAzR,GACVA","file":"index.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"iching\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"iching\"] = factory();\n\telse\n\t\troot[\"iching\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","import { BinaryGF } from \"./BinaryGF\";\r\n\r\n/**\r\n * This class represents a polynomial whose coefficients are elements of a binary Galois field.\r\n *\r\n * @export\r\n * @class BinaryGFPoly\r\n */\r\nexport class BinaryGFPoly {\r\n    private field: BinaryGF;\r\n    private coefficients: Uint8ClampedArray;\r\n\r\n    /**\r\n     * Creates a polynomial whose coefficients are elements of the given BinaryGF.\r\n     *\r\n     * @param {BinaryGF} field - BinaryGF the coefficients belong to.\r\n     * @param {Uint8ClampedArray} coefficients - polynomial coefficients.\r\n     * @throws Will throw an error if the given polynomial is empty.\r\n     */\r\n    public constructor(field: BinaryGF, coefficients: Uint8ClampedArray) {\r\n        if (coefficients.length === 0) {\r\n            throw new Error(\"Polynomial is empty!\");\r\n        }\r\n\r\n        this.field = field;\r\n        // Get leading term: highest degree element with non-zero coefficient,\r\n        // or constant term if all others are zeroes.\r\n        let leading = 0;\r\n        while (leading < coefficients.length - 1 && coefficients[leading] === 0) {\r\n            leading++;\r\n        }\r\n        this.coefficients = coefficients.slice(leading);\r\n    }\r\n\r\n    /**\r\n     * Returns the degree of the instance's polynomial.\r\n     *\r\n     * @returns {number}\r\n     */\r\n    public getDegree(): number {\r\n        return this.coefficients.length - 1;\r\n    }\r\n\r\n    /**\r\n     * Returns the coefficients of the instance's polynomial, from highest degree to lowest.\r\n     *\r\n     * @returns {Uint8ClampedArray}\r\n     */\r\n    public getCoefficients(): Uint8ClampedArray {\r\n        return this.coefficients;\r\n    }\r\n\r\n    /**\r\n     * Returns the coefficient of x^degree in the intance's polynomial.\r\n     *\r\n     * @param {number} degree\r\n     * @returns {number}\r\n     * @throws Will throw an error if degree is outside the range of the polynomial's degree.\r\n     */\r\n    public getCoefficient(degree: number): number {\r\n        if (degree < 0 || degree >= this.coefficients.length) {\r\n            throw new Error(\"Degree must be between 0 and the polynomial's degree!\");\r\n        }\r\n\r\n        return this.coefficients[this.coefficients.length - 1 - degree];\r\n    }\r\n\r\n    /**\r\n     * Evaluates the polynomial at a given value of x.\r\n     * Uses Horner's method to avoid calculating powers of x.\r\n     *\r\n     * @see [Wikipedia's page]{@link https://en.wikipedia.org/wiki/Horner%27s_method} for more info.\r\n     * @param {number} x - The value at which the polynomial is evaluated.\r\n     * @returns {number} The value of the polynomial at given x.\r\n     */\r\n    public evaluateAt(x: number): number {\r\n        if (x === 0) {\r\n            return this.getCoefficient(0);\r\n        }\r\n\r\n        let res = 0;\r\n        for (const co of this.coefficients) {\r\n            res = this.field.add(co, this.field.multiply(res, x));\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Adds a BinaryGFPoly of the same field to the instance's polynomial,\r\n     * and returns the result as a new BinaryGFPoly.\r\n     *\r\n     * @param {BinaryGFPoly} other - BinaryGFPoly to be added.\r\n     * @returns {BinaryGFPoly} sum of the two polynomials.\r\n     * @throws Will throw an error if the two polynomials are of different Galois fields.\r\n     */\r\n    public add(other: BinaryGFPoly): BinaryGFPoly {\r\n        if (this.field !== other.field) {\r\n            throw new Error(\"BinaryGFPolys don't have same BinaryGF field\");\r\n        }\r\n\r\n        if (this.isZero()) {\r\n            return other;\r\n        }\r\n        if (other.isZero()) {\r\n            return this;\r\n        }\r\n\r\n        const resLength = Math.max(this.coefficients.length, other.coefficients.length);\r\n        const resCoefficients = new Uint8ClampedArray(resLength);\r\n        for (let i = 0; i < this.coefficients.length; i++) {\r\n            resCoefficients[i + resLength - this.coefficients.length] = this.field.add(\r\n                resCoefficients[i + resLength - this.coefficients.length], this.coefficients[i],\r\n            );\r\n        }\r\n        for (let i = 0; i < other.coefficients.length; i++) {\r\n            resCoefficients[i + resLength - other.coefficients.length] = this.field.add(\r\n                resCoefficients[i + resLength - other.coefficients.length], other.coefficients[i],\r\n            );\r\n        }\r\n\r\n        return new BinaryGFPoly(this.field, resCoefficients);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the instance's polynomial by a BinaryGFPoly of the same field,\r\n     * and returns the result as a new BinaryGFPoly.\r\n     *\r\n     * @param {BinaryGFPoly} other - BinaryGFPoly to be multiplied.\r\n     * @returns {BinaryGFPoly} product of the two polynomials.\r\n     * @throws Will throw an error if the two polynomials are of different Galois fields.\r\n     */\r\n    public multiplyPoly(other: BinaryGFPoly): BinaryGFPoly {\r\n        if (this.field !== other.field) {\r\n            throw new Error(\"BinaryGFPolys don't have same BinaryGF field\");\r\n        }\r\n\r\n        if (this.isZero() || other.isZero()) {\r\n            return this.field.getZeroPoly();\r\n        }\r\n        if (this.isOne()) {\r\n            return other;\r\n        }\r\n        if (other.isOne()) {\r\n            return this;\r\n        }\r\n\r\n        const resLength = this.coefficients.length + other.coefficients.length - 1;\r\n        const resCoefficients = new Uint8ClampedArray(resLength);\r\n        for (let i = 0; i < this.coefficients.length; i++) {\r\n            for (let j = 0; j < other.coefficients.length; j++) {\r\n                const a = this.coefficients[i];\r\n                const b = other.coefficients[j];\r\n                resCoefficients[i + j] = this.field.add(\r\n                    resCoefficients[i + j], this.field.multiply(a, b),\r\n                );\r\n            }\r\n        }\r\n\r\n        return new BinaryGFPoly(this.field, resCoefficients);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the instance's polynomial by a scalar value,\r\n     * and returns the result as a new BinaryGFPoly.\r\n     *\r\n     * @param {number} scalar - scalar to be multiplied.\r\n     * @returns {BinaryGFPoly} product of the instance's polynomial by scalar.\r\n     */\r\n    public multiplyScalar(x: number): BinaryGFPoly {\r\n        if (x === 0) {\r\n            return this.field.getZeroPoly();\r\n        }\r\n        if (x === 1) {\r\n            return this;\r\n        }\r\n\r\n        const resCoefficients = new Uint8ClampedArray(this.coefficients.length);\r\n        for (let i = 0; i < this.coefficients.length; i++) {\r\n            resCoefficients[i] = this.field.multiply(this.coefficients[i], x);\r\n        }\r\n\r\n        return new BinaryGFPoly(this.field, resCoefficients);\r\n    }\r\n\r\n    /**\r\n     * Divides the instance's polynomial by a BinaryGFPoly of the same field,\r\n     * and returns the result as an array of two BinaryGFPoly elements: quotient and remainder.\r\n     * Uses extended synthetic division.\r\n     *\r\n     * @see [Wikipedia's page]{@link https://en.wikipedia.org/wiki/Synthetic_division}\r\n     * for more info.\r\n     * @param {BinaryGFPoly} other - Divisor.\r\n     * @returns {BinaryGFPoly[]} [quotient, remainder].\r\n     * @throws Will throw an error if the two polynomials are of different Galois fields.\r\n     * @throws Will throw an error in case of division by zero.\r\n     */\r\n    public dividePoly(other: BinaryGFPoly): BinaryGFPoly[] {\r\n        if (this.field !== other.field) {\r\n            throw new Error(\"BinaryGFPolys don't have same BinaryGF field\");\r\n        }\r\n        if (other.isZero()) {\r\n            throw new Error(\"Division by zero!\");\r\n        }\r\n\r\n        // A / B:\r\n        // If A === 0: return [0, 0]\r\n        // If B === 1: return [A, 0]\r\n        if (this.isZero() || other.isOne()) {\r\n            return [this, this.field.getZeroPoly()];\r\n        }\r\n\r\n        const res = new Uint8ClampedArray(this.coefficients);\r\n        const normalizer = other.coefficients[0];\r\n        for (let i = 0; i < this.coefficients.length - other.coefficients.length + 1; i++) {\r\n            res[i] = this.field.divide(res[i], normalizer);\r\n            const coef = res[i];\r\n            if (coef !== 0) {\r\n                for (let j = 1; j < other.coefficients.length; j++) {\r\n                    res[i + j] = this.field.add(\r\n                        res[i + j],\r\n                        this.field.multiply(coef, other.coefficients[j]),\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        const remainderLength = other.coefficients.length - 1;\r\n        return [\r\n            new BinaryGFPoly(this.field, res.slice(0, -remainderLength)),\r\n            new BinaryGFPoly(this.field, res.slice(-remainderLength)),\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Checks if the instance's polynomial is zero.\r\n     *\r\n     * @returns {boolean} True if the polynomial is zero.\r\n     */\r\n    public isZero(): boolean {\r\n        return this.coefficients[0] === 0;\r\n    }\r\n\r\n    /**\r\n     * Checks if the instance's polynomial is one.\r\n     *\r\n     * @returns {boolean} True if the polynomial is one.\r\n     */\r\n    public isOne(): boolean {\r\n        return this.coefficients.length === 1 && this.coefficients[0] === 1;\r\n    }\r\n}\r\n","import { Matrix } from \"./Matrix\";\r\n\r\n/**\r\n * @export\r\n * @class BitMatrix\r\n * @extends {Matrix}\r\n * @description Matrix class to represent bit cells (0 or 1 values).\r\n */\r\nexport class BitMatrix extends Matrix {\r\n    public set(x: number, y: number, value: number) {\r\n        this.data[y * this.width + x] = value === 0 ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Convert BitMatrix to image pixels stored as ImageData interface.\r\n     *\r\n     * @returns {ImageData}\r\n     * @memberof BitMatrix\r\n     */\r\n    public toImage(): ImageData {\r\n        const width = this.width;\r\n        const height = this.height;\r\n        const data = new Uint8ClampedArray(4 * height * width);\r\n        let idx: number = 0;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                let color: number = 255;\r\n                if (this.get(x, y) === 1) {\r\n                    color = 0;\r\n                }\r\n                data[idx] = color;\r\n                data[idx + 1] = color;\r\n                data[idx + 2] = color;\r\n                data[idx + 3] = 255;\r\n                idx += 4;\r\n            }\r\n        }\r\n        return { width, height, data };\r\n    }\r\n}\r\n","import { BinaryGF, ReedSolomonEncoder } from \"../common/reedsolomon\";\r\nimport { EncodedIChing } from \"./EncodedIChing\";\r\n\r\n/**\r\n * Encoder class encapsulating IChing content encoding methods.\r\n *\r\n * @export\r\n * @class Encoder\r\n */\r\nexport class Encoder {\r\n    /**\r\n     * VERSION - IChing code version.\r\n     */\r\n    public static VERSION: number = 1;\r\n    /**\r\n     * Maximum size of IChing code.\r\n     */\r\n    public static MAX_SIZE: number = 64;\r\n    /**\r\n     * Offset of the start of the payload (Number of metadata symbols).\r\n     */\r\n    public static OFFSET: number = 2;\r\n    /**\r\n     * Error correction level none: no error correction capabilities will be added.\r\n     */\r\n    public static EC_NONE: number = 0;\r\n    /**\r\n     * Error correction level low: up to 5% of symbols can be corrected.\r\n     */\r\n    public static EC_LOW: number = 0.05;\r\n    /**\r\n     * Error correction level medium: up to 15% of symbols can be corrected.\r\n     */\r\n    public static EC_MEDIUM: number = 0.15;\r\n    /**\r\n     * Error correction level high: up to 25% of symbols can be corrected.\r\n     */\r\n    public static EC_HIGH: number = 0.25;\r\n    /**\r\n     * Number of error correction symbols needed to correct a single error.\r\n     */\r\n    public static SYMBOLS_PER_ERROR: number = 2;\r\n    /**\r\n     * Character set supported in IChing codes.\r\n     */\r\n    public static ALPHABET: string =\r\n        `ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*(){}[]_+-=.,:;/?<>\" `;\r\n\r\n    /**\r\n     * Creates an IChing code from provided content.\r\n     *\r\n     * @param {string} content\r\n     * @param {number} ecLevel - percentage of symbols that can be corrected after encoding, must\r\n     * be between 0 - 1.\r\n     * @returns {@link EncodedIChing} An EncodedIChing object with the version, size,\r\n     * and data fields set.\r\n     * @throws Will throw an error if the payload to be encoded is empty.\r\n     * @throws Will throw an error if payload and error correction level combination is bigger than\r\n     * the maximum IChing size.\r\n     * @throws Will throw an error if the payload contains an invalid character.\r\n     * @throws Will throw an error if ecLevel out of 0 - 1 boundary.\r\n     * @throws Will throw an error if Reed-Solomon encoding fails.\r\n     */\r\n    public encode(payload: string, ecLevel: number): EncodedIChing {\r\n        if (payload.length === 0) {\r\n            throw new Error(\"Empty payload!\");\r\n        }\r\n        if (ecLevel < 0 || ecLevel > 1) {\r\n            throw new Error(\"Error correction percentage must be a value between 0 - 1!\");\r\n        }\r\n\r\n        // Error correction symbols required to match error correction level.\r\n        let ecSymbols = Math.ceil(payload.length * ecLevel) * Encoder.SYMBOLS_PER_ERROR;\r\n\r\n        // Minimum number of symbols required to encode content at error correction level.\r\n        const minimumSize = Encoder.OFFSET + payload.length + ecSymbols;\r\n\r\n        if (minimumSize > Encoder.MAX_SIZE) {\r\n            throw new Error(\"Payload and error correction level combination is too big!\");\r\n        }\r\n\r\n        // Calculate square size that fits content at error correction level.\r\n        let sideLength = 1;\r\n        while (sideLength * sideLength < minimumSize) {\r\n            sideLength++;\r\n        }\r\n        const trueSize = sideLength * sideLength;\r\n\r\n        // Re-evaluate error correction symbols to fit square. Must be even.\r\n        ecSymbols += (trueSize - minimumSize) & (~1);\r\n\r\n        // Initialise data array.\r\n        const data: Uint8ClampedArray = new Uint8ClampedArray(trueSize - ecSymbols);\r\n        // If size is odd, fill extra symbol.\r\n        if ((trueSize - minimumSize) & 1) {\r\n            data[trueSize - 1 - ecSymbols] = 0;\r\n        }\r\n        data[0] = Encoder.VERSION;\r\n        data[1] = payload.length;\r\n        payload = payload.toUpperCase();\r\n        for (let i = 0; i < payload.length; i++) {\r\n            const mappedChar = Encoder.ALPHABET.indexOf(payload[i]);\r\n            if (mappedChar === -1) {\r\n                throw new Error(\"Invalid character in payload!\");\r\n            }\r\n            data[i + Encoder.OFFSET] = mappedChar;\r\n        }\r\n\r\n        // Compute and append error correction symbols.\r\n        const rsEncoder = new ReedSolomonEncoder(BinaryGF.BINARY_GF_6);\r\n        let encodedData: Uint8ClampedArray;\r\n        try {\r\n            encodedData = rsEncoder.encode(data, ecSymbols);\r\n        } catch (e) {\r\n            throw new Error(\"Reed-Solomon encoding failed: '\" + e.message + \"'!\");\r\n        }\r\n\r\n        return { version: data[0], size: sideLength, data: encodedData, imageData: null };\r\n    }\r\n}\r\n","/**\r\n * @export\r\n * @abstract\r\n * @class Matrix\r\n * @description Base class to represent a simple matrix with Uint8Clamped data\r\n */\r\nexport abstract class Matrix {\r\n    /**\r\n     * Number of columns in the Matrix\r\n     */\r\n    public width: number;\r\n    /**\r\n     * Number of rows in the Matrix\r\n     */\r\n    public height: number;\r\n    /**\r\n     * Matrix Internal data array - values between (0 - 255)\r\n     */\r\n    protected data: Uint8ClampedArray;\r\n\r\n    constructor(width: number, height: number) {\r\n        if (!Number.isInteger(width) || !Number.isInteger(height)) {\r\n            throw new Error(\"Width and height should be integers!\");\r\n        }\r\n        this.width = width;\r\n        this.height = height;\r\n        this.data = new Uint8ClampedArray(width * height);\r\n    }\r\n\r\n    public get(x: number, y: number) {\r\n        return this.data[y * this.width + x];\r\n    }\r\n}\r\n","import { Matrix } from \"./Matrix\";\r\n\r\n/**\r\n * @export\r\n * @class ByteMatrix\r\n * @extends {Matrix}\r\n * @description Matrix class to represent byte cells.\r\n */\r\nexport class ByteMatrix extends Matrix {\r\n    public set(x: number, y: number, value: number) {\r\n        this.data[y * this.width + x] = value;\r\n    }\r\n}\r\n","export { BinaryGF } from \"./BinaryGF\";\r\nexport { BinaryGFPoly } from \"./BinaryGFPoly\";\r\nexport { ReedSolomonEncoder } from \"./ReedSolomonEncoder\";\r\nexport { ReedSolomonDecoder } from \"./ReedSolomonDecoder\";\r\n","export { Writer } from \"./Writer\";\r\n","/**\r\n * Calculates array sum\r\n *\r\n * @export\r\n * @param {any} arr - Input array.\r\n * @returns - The sum of the array.\r\n */\r\nexport function sumArray(arr: any): number {\r\n    return (arr as any).reduce((sum: number, x: number) => sum + x);\r\n}\r\n","import { BitMatrix } from \"../../BitMatrix\";\r\nimport { Point } from \"../../geometry\";\r\nimport { sumArray } from \"../../utils\";\r\nimport { LocationError } from \"./LocationError\";\r\n\r\n/**\r\n * Represents pattern ratio error and size average for each probable pattern location.\r\n * @interface PatternMeasures\r\n */\r\ninterface PatternMeasures {\r\n    /**\r\n     * The corrected center of the pattern.\r\n     */\r\n    location: Point;\r\n    /**\r\n     * The pattern state array when intersected from certain angle.\r\n     */\r\n    state: Uint16Array;\r\n    /**\r\n     * Error representing how much pattern center is shifted from the actual center.\r\n     */\r\n    centerError: number;\r\n    /**\r\n     * Pattern size.\r\n     */\r\n    patternSize: number;\r\n}\r\n\r\n/**\r\n * @export\r\n * @class PatternLocator\r\n * @description Locates all possible locations of patterns having a certain ratio\r\n * and calculates the error for each location.\r\n */\r\nexport class PatternLocator {\r\n    /**\r\n     * Main class method - locates possible locations of patterns with certain ratio.\r\n     *\r\n     * @param {BitMatrix} matrix - Matrix representing binarized image.\r\n     * @returns {LocationError[]} - Array of all possible locations of the patterns.\r\n     * @memberof PatternLocator\r\n     */\r\n\r\n    /**\r\n     * Precalculated square root of 2\r\n     */\r\n    public static SQRT2 = 1.41421356237;\r\n    /**\r\n     * Precalculated square root of 5\r\n     */\r\n    public static SQRT5 = 2.2360679775;\r\n\r\n    /**\r\n     * Factor to reduce effect of the pattern size error in the final error calculations.\r\n     */\r\n    public static SIZE_ERROR_FACTOR = 0.1;\r\n\r\n    private matrix: BitMatrix;\r\n    private ratios: Uint8Array;\r\n    private startX: number;\r\n    private startY: number;\r\n    private endX: number;\r\n    private endY: number;\r\n    private additionalChecks: boolean;\r\n\r\n    public locate(\r\n        matrix: BitMatrix,\r\n        ratios: Uint8Array,\r\n        additionalChecks: boolean = false,\r\n        startPoint: Point = { x: 0, y: 0 },\r\n        endPoint: Point = { x: matrix.width, y: matrix.height },\r\n    ): LocationError[] {\r\n        this.matrix = matrix;\r\n        this.ratios = ratios;\r\n        this.startX = startPoint.x;\r\n        this.startY = startPoint.y;\r\n        this.endX = endPoint.x;\r\n        this.endY = endPoint.y;\r\n        this.additionalChecks = additionalChecks;\r\n\r\n        const locations = [];\r\n        // Initialize state array to keep track of number of pixels in\r\n        // each state of the patterns\r\n        const state = new Uint16Array(ratios.length);\r\n        let stateIdx = 0;\r\n\r\n        // Scan each other line. This is safe to do and will not skip patterns, while improving\r\n        // performance significantly.\r\n        for (let y = this.startY; y < this.endY; y += 2) {\r\n            for (let x = this.startX; x < this.endX; ++x) {\r\n                if ((stateIdx & 1) === matrix.get(x, y)) {\r\n                    // if encountered white cell at even state, or black cell at odd state, then\r\n                    // state has changed, and we advance to the next state.\r\n                    ++stateIdx;\r\n                    if (stateIdx === ratios.length) {\r\n                        // If we reached the final state change, then check if it's a valid pattern\r\n                        if (this.isValidPattern(state)) {\r\n                            const initialCenter: Point = this.centerFromEnd({ x: x - 1, y }, state);\r\n                            const maxCount = state[ratios.length >> 1] << 2;\r\n\r\n                            // Check pattern in vertical direction.\r\n                            const vertical = this.calculatePatternMeasures(\r\n                                initialCenter, 0, 1, maxCount);\r\n                            const validPattern = this.isValidPattern(vertical.state);\r\n\r\n                            // If valid pattern, calculates its error and push it to results\r\n                            if (validPattern === true) {\r\n                                locations.push(this.calculateLocationError(\r\n                                    initialCenter, maxCount,\r\n                                ));\r\n                            }\r\n                        }\r\n                        // we still can make use of the last states as new ones in another\r\n                        // pattern except for the first two states.\r\n                        for (let i = 2; i < state.length; ++i) {\r\n                            state[i - 2] = state[i];\r\n                        }\r\n                        // make the two remaining states zeros\r\n                        state[ratios.length - 1] = state[ratios.length - 2] = 0;\r\n                        stateIdx = ratios.length - 2;\r\n                    }\r\n                }\r\n                // In all cases increament number of pixels in the current state.\r\n                ++state[stateIdx];\r\n            }\r\n\r\n            // Handle the case that the image right side cuts a pattern.\r\n            // This case could happen if a user is trying to fit the code to the screen exactly.\r\n            if (stateIdx === ratios.length - 1 && this.isValidPattern(state)) {\r\n                const initialCenter: Point = this.centerFromEnd({ x: this.endX - 1, y }, state);\r\n                locations.push(this.calculateLocationError(\r\n                    initialCenter, state[ratios.length >> 1] * 2,\r\n                ));\r\n            } else {\r\n                // empty all pattern states since no pattern should continue to the begining of\r\n                // a new line.\r\n                stateIdx = 0;\r\n                for (let i = 0; i < ratios.length; ++i) {\r\n                    state[i] = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        return locations;\r\n    }\r\n\r\n    /**\r\n     * Calculate pattern center pixel gives it's end pixel and the pattern state array.\r\n     *\r\n     * @private\r\n     * @param {Point} patternEnd - Pattern end pixel.\r\n     * @param {Uint16Array} state - Pattern state array.\r\n     * @returns {Point} - Pattern center pixel.\r\n     * @memberof PatternLocator\r\n     */\r\n    private centerFromEnd(patternEnd: Point, state: Uint16Array): Point {\r\n        let stateIdx = state.length >> 1;\r\n        let displacement = state[stateIdx] >> 1;\r\n        while (++stateIdx < state.length) {\r\n            displacement += state[stateIdx];\r\n        }\r\n        return {\r\n            x: patternEnd.x - displacement,\r\n            y: patternEnd.y,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Checks if the ratios of calculated states indeed form a valid pattern.\r\n     *\r\n     * @private\r\n     * @param {Uint16Array} state - Array represents calculated states for\r\n     * the probable pattern.\r\n     * @returns {boolean} - either it's a valid pattern or not.\r\n     * @memberof PatternLocator\r\n     */\r\n    private isValidPattern(state: Uint16Array): boolean {\r\n        let sum = 0;\r\n        for (const count of state) {\r\n            if (count === 0) {\r\n                // if any of the states contains no pixel then it's not a valid state.\r\n                return false;\r\n            }\r\n            sum += count;\r\n        }\r\n        const ratiosSum = sumArray(this.ratios);\r\n        // If the pattern doesn't contain number of pixels at least equal to the\r\n        // sum of the base ratios, then it's not a valid pattern for sure.\r\n        if (sum < ratiosSum) {\r\n            return false;\r\n        }\r\n\r\n        const unit = sum / ratiosSum;\r\n        // the maximum error that we can tolerate for each unit.\r\n        const maxVariance = unit / 2;\r\n        // then we check that each state contains the needed pixels.\r\n        let validPattern = true;\r\n        for (let i = 0; i < this.ratios.length; ++i) {\r\n            if (Math.abs(state[i] - unit * this.ratios[i]) > this.ratios[i] * maxVariance) {\r\n                validPattern = false;\r\n            }\r\n        }\r\n        return validPattern;\r\n    }\r\n\r\n    /**\r\n     * Checks if the pattern will match the required ratios if intersected from multiple angles\r\n     * and calculate the error according to that.\r\n     * The ratio error is calculated using normalized RMS (root mean square) method to get\r\n     * their standard error when measured from different prespective.\r\n     * @see https://en.wikipedia.org/wiki/Root-mean-square_deviation\r\n     * @private\r\n     * @param {Point} patternCenter - The center of the pattern to calculate error for.\r\n     * @param {number} maxCount - The maximum possible number of pixels a pattern state could have.\r\n     * @returns {LocationError} - The corrected pattern center and the combined error of\r\n     * that location.\r\n     * @memberof PatternLocator\r\n     */\r\n    private calculateLocationError(patternCenter: Point, maxCount: number): LocationError {\r\n        // Calculate pattern state array.\r\n        const dx = [0, 1, 1, -1, 2, -1];\r\n        const dy = [1, 0, 1, 1, 1, 2];\r\n        const factor = [\r\n            1, 1, PatternLocator.SQRT2, PatternLocator.SQRT2,\r\n            PatternLocator.SQRT5, PatternLocator.SQRT5,\r\n        ];\r\n        let checksCount = dx.length;\r\n        if (!this.additionalChecks) {\r\n            checksCount -= 2;\r\n        }\r\n\r\n        const ratiosSum = sumArray(this.ratios);\r\n        const measures: PatternMeasures[] = [];\r\n        let averageSize = 0;\r\n        let standardRatioError = 0;\r\n        let centerError = 0;\r\n        for (let i = 0; i < checksCount; ++i) {\r\n            measures.push(\r\n                this.calculatePatternMeasures(patternCenter, dx[i], dy[i], maxCount / factor[i]),\r\n            );\r\n            averageSize +=  measures[i].patternSize * factor[i];\r\n            // standard ratio error is equal to RMS of each cross ratioError, but we won't take the\r\n            // root since we are going to need the squared value later.\r\n            // Each cross ratioError is squared already so we won't square any of them again.\r\n            standardRatioError += this.calculateStateError(\r\n                measures[i].state, measures[i].patternSize / ratiosSum,\r\n            );\r\n            centerError += measures[i].centerError;\r\n        }\r\n        // Calculate pattern average size in order to be used as the mean in the RMS equation.\r\n        averageSize /= checksCount;\r\n        centerError /= checksCount;\r\n        standardRatioError /= checksCount * this.ratios.length;\r\n\r\n        let sizeError = 0;\r\n        for (let i = 0; i < checksCount; ++i) {\r\n            sizeError += (1 - measures[i].patternSize / averageSize) *\r\n                (1 - measures[i].patternSize / averageSize);\r\n        }\r\n        sizeError /= checksCount;\r\n        // multiply sizeError by factor to minimize it's effect in the total error.\r\n        // it has to be minimized in order to give tolerance for multiple directions to\r\n        // have different sizes.\r\n        sizeError *= PatternLocator.SIZE_ERROR_FACTOR;\r\n\r\n        // Also use the corrected center as the new pattern center.\r\n        // No center corrections happens from the diagonals since the vertical and horizontal\r\n        // correction is enough to adjust the center.\r\n        const correctedCenter = {\r\n            x: measures[1].location.x,\r\n            y: measures[0].location.y,\r\n        };\r\n\r\n        return {\r\n            location: correctedCenter,\r\n            error: standardRatioError + centerError + sizeError,\r\n            size: averageSize,\r\n            standardRatioError,\r\n            centerError,\r\n            sizeError,\r\n            measures,\r\n            patternCenter,\r\n        } as LocationError;\r\n    }\r\n\r\n    /**\r\n     * Calculates the sum of each state error in the state array to be used in error calculations\r\n     * using the RMS equation (x - mean)^2 / N\r\n     *\r\n     * @private\r\n     * @param {Uint16Array} state - State array representing how many pixels represent\r\n     * each pattern state.\r\n     * @param {number} averageUnit - Average pattern state unit size.\r\n     * @returns {number} - Normalized sum(Xi - mean)^2.\r\n     * @memberof PatternLocator\r\n     * @see https://en.wikipedia.org/wiki/Normalization_(statistics)\r\n     */\r\n    private calculateStateError(state: Uint16Array, averageUnit: number): number {\r\n        let error = 0;\r\n        for (let i = 0; i < this.ratios.length; ++i) {\r\n            const unitError = (state[i] / averageUnit / this.ratios[i]  - 1);\r\n            error += unitError * unitError;\r\n        }\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * Calculates the pattern state array when intersected using a line with dx,dy direction\r\n     * and correct the pattern center if needed.\r\n     *\r\n     * @private\r\n     * @param {Point} patternCenter - Initial Pattern center coordinates.\r\n     * @param {number} dx - X-axis displacement direction.\r\n     * @param {number} dy - Y-axis displacement direction.\r\n     * @param {number} maxCount - The maximum possible number of pixels a pattern state could have.\r\n     * @returns {PatternMeasures} - Pattern state resutling from the line cross check and\r\n     * corrected pattern center.\r\n     * @memberof PatternLocator\r\n     */\r\n    private calculatePatternMeasures(\r\n        patternCenter: Point,\r\n        dx: number,\r\n        dy: number,\r\n        maxCount: number,\r\n    ): PatternMeasures {\r\n        if (dx === 0 && dy === 0) {\r\n            throw new Error(\"x-axis and y-axis displacement should be either 1 or -1, \\\r\n            and they shouldn't be both zeros!\");\r\n        }\r\n\r\n        const state = new Uint16Array(this.ratios.length);\r\n        let x = patternCenter.x;\r\n        let y = patternCenter.y;\r\n        let xEnd = dx === -1 ? -1 : this.matrix.width;\r\n        let yEnd = dy === -1 ? -1 : this.matrix.height;\r\n        const midStateIdx = this.ratios.length >> 1;\r\n        let stateIdx = midStateIdx;\r\n        // Count pixels from the center and going forward.\r\n        while (x !== xEnd && y !== yEnd) {\r\n            if ((stateIdx & 1) === this.matrix.get(x, y)) {\r\n                // if encountered white cell at even state, or black cell at odd state, then\r\n                // state has changed, and we advance to the next state.\r\n                ++stateIdx;\r\n                if (stateIdx === this.ratios.length) {\r\n                    // If we reached the final state then break.\r\n                    break;\r\n                }\r\n            }\r\n            // In all cases increament number of pixels in the current state and\r\n            // get out if the state count became larger than the maximum possible.\r\n            if (++state[stateIdx] > maxCount) {\r\n                break;\r\n            }\r\n            x += dx;\r\n            y += dy;\r\n        }\r\n        const sumForward = state[midStateIdx];\r\n\r\n        // exact same logic as above but counting backward to cover the full pattern.\r\n        x = patternCenter.x - dx;\r\n        y = patternCenter.y - dy;\r\n        xEnd = dx === 1 ? -1 : this.matrix.width;\r\n        yEnd = dy === 1 ? -1 : this.matrix.height;\r\n        stateIdx = midStateIdx;\r\n        while (x !== xEnd && y !== yEnd) {\r\n            if ((stateIdx & 1) === this.matrix.get(x, y)) {\r\n                --stateIdx;\r\n                if (stateIdx === -1) {\r\n                    break;\r\n                }\r\n            }\r\n            if (++state[stateIdx] > maxCount) {\r\n                break;\r\n            }\r\n            x -= dx;\r\n            y -= dy;\r\n        }\r\n        const sumBackward = state[midStateIdx] - sumForward;\r\n        let centerError = (1 - sumForward / sumBackward);\r\n        centerError *= centerError;\r\n\r\n        // adjust the pattern center according to number of pixels on both sides of the old center.\r\n        const correctedCenter = {\r\n            x: patternCenter.x + Math.floor((sumForward - sumBackward) / 2) * dx,\r\n            y: patternCenter.y + Math.floor((sumForward - sumBackward) / 2) * dy,\r\n        };\r\n        return { location: correctedCenter, state, centerError, patternSize: sumArray(state) };\r\n    }\r\n}\r\n","/**\r\n * Interface to represent 2D point on image grid - could have floating-point coordinates\r\n *\r\n * @export\r\n * @interface Point\r\n */\r\nexport interface Point {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\n/**\r\n * Calculates the squared euclidean distance between two points.\r\n *\r\n * @export\r\n * @param {Point} a - The first point.\r\n * @param {Point} b - The second point.\r\n * @returns {number}\r\n */\r\nexport function sqDistance(a: Point, b: Point): number {\r\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\r\n}\r\n\r\n/**\r\n * Calculates the euclidean distance between two points.\r\n *\r\n * @export\r\n * @param {Point} a - The first point.\r\n * @param {Point} b - The second point.\r\n * @returns {number}\r\n */\r\nexport function distance(a: Point, b: Point): number {\r\n    return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\r\n}\r\n\r\n/**\r\n * Calculates the vector a -> b (as a point).\r\n *\r\n * @export\r\n * @param {Point} a - The first vector point.\r\n * @param {Point} b - The second vector point.\r\n * @returns {Point} - vector(a -> b)\r\n */\r\nexport function vec(a: Point, b: Point): Point {\r\n    return { x: b.x - a.x, y: b.y - a.y };\r\n}\r\n\r\n/**\r\n * Calculates the cross product magnitude between two vectors\r\n *\r\n * @export\r\n * @param {Point} a - The first vector.\r\n * @param {Point} b - The second vector.\r\n * @returns {number}\r\n */\r\nexport function cross(a: Point, b: Point): number {\r\n    return a.x * b.y - a.y * b.x;\r\n}\r\n\r\n/**\r\n * Checks if two points are nearly the same.\r\n *\r\n * @export\r\n * @param {Point} a - The first point.\r\n * @param {Point} b - The second point.\r\n * @param {number} eps - Epsilon value which is the maximum distance between\r\n * two points to be considered equal.\r\n * @returns {boolean}\r\n */\r\nexport function nearlySame(a: Point, b: Point, eps: number): boolean {\r\n    return Math.abs((a.x - b.x)) < eps && Math.abs(a.y - b.y) < eps;\r\n}\r\n","export { decode } from \"./core/decoder\";\r\nexport { encode } from \"./core/encoder\";\r\n","import { FastAdaptiveBinarizer } from \"./binarizer\";\r\nimport { DecodedIChing } from \"./DecodedIChing\";\r\nimport { Decoder } from \"./Decoder\";\r\nimport { Extractor } from \"./extractor\";\r\nimport { Locator } from \"./locator\";\r\nimport { CodeTransform } from \"./transform\";\r\n\r\n/**\r\n * Decoder entry point - Decodes RGBA image containing IChing code to plain text.\r\n *\r\n * @export\r\n * @param {Uint8ClampedArray} data - Array containing RGBA image pixels, each pixel consists\r\n * of four consecutive cells representing red, green, blue, alpha values for the pixel.\r\n * [r0, g0, b0, a0, r1, g1, b1, a1, ...]\r\n * @param {number} width - Image width.\r\n * @param {number} height - Image Height.\r\n * @returns {DecodedIChing} - Decoded IChing contains plain data, and info about the original code.\r\n */\r\nexport function decode(data: Uint8ClampedArray, width: number, height: number): DecodedIChing {\r\n    try {\r\n        return decodeInternal(data, width, height);\r\n    } catch (e) {\r\n        for (let row = 0, idx = 0; row < height; row++) {\r\n            for (let col = 0; col < width; col++, idx += 4) {\r\n                data[idx] = 255 - data[idx];\r\n                data[idx + 1] = 255 - data[idx + 1];\r\n                data[idx + 2] = 255 - data[idx + 2];\r\n            }\r\n        }\r\n        return decodeInternal(data, width, height);\r\n    }\r\n}\r\n\r\nfunction decodeInternal(data: Uint8ClampedArray, width: number, height: number): DecodedIChing {\r\n    const binarizer = new FastAdaptiveBinarizer();\r\n    const binarizedMatrix = binarizer.binarize(data, width, height);\r\n\r\n    const locator = new Locator();\r\n    const patterns = locator.locate(binarizedMatrix);\r\n\r\n    const transformer = new CodeTransform();\r\n    const transformedMatrix = transformer.transform(binarizedMatrix, patterns);\r\n\r\n    const extractor = new Extractor();\r\n    const extractedData = extractor.extract(transformedMatrix);\r\n\r\n    const decoder = new Decoder();\r\n    const decodedData = decoder.decode(extractedData);\r\n    decodedData.patterns = patterns;\r\n\r\n    return decodedData;\r\n}\r\n","export { FastAdaptiveBinarizer } from \"./FastAdaptiveBinarizer\";\r\n","/**\r\n * This is the main Binarization method at the library, it's both fast and accurate and suitable to\r\n * wide ranges of end devices.\r\n */\r\nimport { BitMatrix } from \"../../BitMatrix\";\r\nimport { ByteMatrix } from \"../../ByteMatrix\";\r\nimport { Binarizer } from \"./Binarizer\";\r\n\r\n/**\r\n * @export\r\n * @class FastAdaptiveBinarizer\r\n * @description Binarizer class uses fast enhanced adaptive threshold method to binarize pixels.\r\n * @extends {Binarizer}\r\n */\r\nexport class FastAdaptiveBinarizer extends Binarizer {\r\n\r\n    /**\r\n     * Constant substracted from the local mean value for each block.\r\n     */\r\n\r\n    public static MEAN_CONST = 3;\r\n    /**\r\n     * Minimum possible variance for a block in order to be considered mix of different colors.\r\n     */\r\n    public static MIN_VARIANCE = 20;\r\n    /**\r\n     * Block size for the local mean calculations required in the adaptive thresholding algorithm.\r\n     */\r\n    public static BLOCK_SIZE = 30;\r\n\r\n    /**\r\n     * @description Main class method, converts RGBA image to binary image\r\n     * @param {Uint8ClampedArray} data - Array containing RGBA image pixels, each pixel consists\r\n     * of four consecutive cells representing red, green, blue, alpha values for the pixel.\r\n     * [r0, g0, b0, a0, r1, g1, b1, a1, ...]\r\n     * @param {number} width - Image width.\r\n     * @param {number} height - Image height.\r\n     * @returns {BitMatrix} - Matrix contains the binarized image, each pixel has 0 or 1 value.\r\n     * @memberof FastAdaptiveBinarizer\r\n     */\r\n    public binarize(data: Uint8ClampedArray, width: number, height: number): BitMatrix {\r\n        if (data.length !== width * height * 4) {\r\n            throw new Error(\"incorrect data length!\");\r\n        }\r\n        if (width < FastAdaptiveBinarizer.BLOCK_SIZE || height < FastAdaptiveBinarizer.BLOCK_SIZE) {\r\n            throw new Error(\"Image is too small!\");\r\n        }\r\n        // Convert the photo to single channel.\r\n        const grayscaleMatrix = Binarizer.toGrayscale(data, width, height);\r\n        // Calculate the adaptive threshold for each block.\r\n        const T = this.calculateLocalMeanTable(grayscaleMatrix);\r\n        const minVariance = FastAdaptiveBinarizer.MIN_VARIANCE;\r\n        const constant = FastAdaptiveBinarizer.MEAN_CONST;\r\n        const binarized = new BitMatrix(width, height);\r\n        const blockSize = FastAdaptiveBinarizer.BLOCK_SIZE;\r\n        const halfBlock = blockSize >> 1;\r\n        for (let y = 0, blockY; y < height; ++y) {\r\n            blockY = Math.max(Math.min(y + halfBlock, height - 1) - blockSize + 1, 0);\r\n\r\n            for (let x = 0, blockX; x < width; ++x) {\r\n                blockX = Math.max(Math.min(x + halfBlock, width - 1) - blockSize + 1, 0);\r\n\r\n                const color = grayscaleMatrix.get(x, y);\r\n                let threshold = T.get(blockX, blockY);\r\n\r\n                if (Math.abs(threshold - color) < minVariance) {\r\n                    // If the variance is small then consider the block pixels has the same\r\n                    // color equal to the left & top pixel average color since they are contained\r\n                    // in the same block.\r\n                    if (x > 0 && y > 0) {\r\n                        const neighboursAvg = (\r\n                            grayscaleMatrix.get(x - 1, y) +\r\n                            grayscaleMatrix.get(x, y - 1) +\r\n                            grayscaleMatrix.get(x - 1, y - 1)\r\n                        ) / 3;\r\n                        if (Math.abs(threshold - color) < Math.abs(neighboursAvg - color)) {\r\n                            threshold = neighboursAvg;\r\n                        }\r\n                    } else {\r\n                        // if it's border then assume it's a white background, make average < min\r\n                        threshold = color / 2 - constant;\r\n                    }\r\n                }\r\n                binarized.set(x, y, color < threshold ? 1 : 0);\r\n                grayscaleMatrix.set(x, y, threshold);\r\n            }\r\n        }\r\n        return binarized;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @description Calculates the threshold for each block, the mean of the block pixels.\r\n     * @param {ByteMatrix} mat - greyscale matrix.\r\n     * @returns {ByteMatrix} - The threshold matrix, each cell represents\r\n     * threshold value for the corresponding block.\r\n     * @memberof FastAdaptiveBinarizer\r\n     */\r\n    private calculateLocalMeanTable(mat: ByteMatrix): ByteMatrix {\r\n        const T = new ByteMatrix(mat.width, mat.height);\r\n        const rowSum = new Uint16Array(mat.height);\r\n        const blockSize = FastAdaptiveBinarizer.BLOCK_SIZE;\r\n        const constant = FastAdaptiveBinarizer.MEAN_CONST;\r\n        const endX = T.width - blockSize + 1;\r\n        const endY = T.height - blockSize + 1;\r\n\r\n        // Handle the first row and column as a special case to avoid\r\n        // unnecessary conditions in the loop.\r\n        for (let y = 0; y < T.height; ++y) {\r\n            for (let x = 0; x < blockSize; ++x) {\r\n                rowSum[y] += mat.get(x, y);\r\n            }\r\n        }\r\n\r\n        let colSum = 0;\r\n        for (let y = 0; y < blockSize; ++y) {\r\n            colSum += rowSum[y];\r\n        }\r\n        T.set(0, 0, colSum / (blockSize * blockSize) - constant);\r\n\r\n        let prev = colSum;\r\n        for (let y = 1; y < endY; ++y) {\r\n            colSum = prev - rowSum[y - 1] + rowSum[y + blockSize - 1];\r\n            T.set(0, y, colSum / (blockSize * blockSize) - constant);\r\n            prev = colSum;\r\n        }\r\n\r\n        // resolve the remaining matrix\r\n        for (let x = 1; x < endX; ++x) {\r\n            for (let y = 0; y < T.height; ++y) {\r\n                rowSum[y] += mat.get(x + blockSize - 1, y) - mat.get(x - 1, y);\r\n            }\r\n\r\n            // handle the first row in that column\r\n            colSum = 0;\r\n            for (let y = 0; y < blockSize; ++y) {\r\n                colSum += rowSum[y];\r\n            }\r\n            T.set(x, 0, colSum / (blockSize * blockSize) - constant);\r\n\r\n            prev = colSum;\r\n            for (let y = 1; y < endY; ++y) {\r\n                colSum = prev - rowSum[y - 1] + rowSum[y + blockSize - 1];\r\n                T.set(x, y, colSum / (blockSize * blockSize) - constant);\r\n                prev = colSum;\r\n            }\r\n        }\r\n        return T;\r\n    }\r\n}\r\n","import { ByteMatrix } from \"../../ByteMatrix\";\r\n\r\nexport abstract class Binarizer {\r\n    /**\r\n     * Grayscale conversion cofficients.\r\n     * ITU-R recommendation (BT.709).  This formula, sometimes called Luma\r\n     * Gray = (Red * 0.2126 + Green * 0.7152 + Blue * 0.0722)\r\n     */\r\n    public static TO_GRAY = {\r\n        RED: 0.2126,\r\n        GREEN: 0.7152,\r\n        BLUE: 0.0722,\r\n    };\r\n\r\n    /**\r\n     * @description Transforms image data to grayscale ByteMatrix\r\n     * @param {Uint8ClampedArray} data - Array containing RGBA image pixels, each pixel consists\r\n     * of four consecutive cells representing red, green, blue, alpha values for the pixel.\r\n     * [r0, g0, b0, a0, r1, g1, b1, a1, ...]\r\n     * @param {number} cols - Number of columns of the original image\r\n     * @param {number} rows - Number of rows of the original image\r\n     * @returns {ByteMatrix} - ByteMatrix contains grayscale values converted using luma formula\r\n     */\r\n    public static toGrayscale(data: Uint8ClampedArray, width: number, height: number): ByteMatrix {\r\n        const grayscaleMatrix = new ByteMatrix(width, height);\r\n        for (let y = 0; y < height; ++y) {\r\n            for (let x = 0; x < width; ++x) {\r\n                // 4 cells to hold RGBA values for each pixels\r\n                const idx = (y * width + x) * 4;\r\n                const red = data[idx + 0];\r\n                const green = data[idx + 1];\r\n                const blue = data[idx + 2];\r\n                grayscaleMatrix.set(x, y,\r\n                    red * Binarizer.TO_GRAY.RED +\r\n                    green * Binarizer.TO_GRAY.GREEN +\r\n                    blue * Binarizer.TO_GRAY.BLUE);\r\n            }\r\n        }\r\n        return grayscaleMatrix;\r\n    }\r\n}\r\n","import { BinaryGF, ReedSolomonDecoder } from \"../common/reedsolomon\";\r\nimport { Encoder } from \"../encoder/Encoder\";\r\nimport { DecodedIChing } from \"./DecodedIChing\";\r\n\r\n/**\r\n * Decoder class encapsulating IChing content decoding methods.\r\n *\r\n * @export\r\n * @class Decoder\r\n */\r\nexport class Decoder {\r\n    /**\r\n     * Creates a payload string from received IChing raw data. Assumes metadata symbols are always\r\n     * correct.\r\n     *\r\n     * @param {Uint8ClampedArray} received - Raw data.\r\n     * @returns { DecodedIChing } - Decoded payload and code metadata.\r\n     */\r\n    public decode(received: Uint8ClampedArray): DecodedIChing {\r\n        const version = received[0];\r\n        const size = Math.round(Math.sqrt(received.length));\r\n\r\n        if (version !== Encoder.VERSION || size * size !== received.length) {\r\n            throw new Error(\"Invalid IChing code!\");\r\n        }\r\n\r\n        // Metadata length.\r\n        const offset: number = Encoder.OFFSET;\r\n\r\n        // Payload length.\r\n        const dataLength = received[1];\r\n        if (dataLength === 0 || dataLength + offset > received.length) {\r\n            throw new Error(\"Invalid IChing code!\");\r\n        }\r\n\r\n        // Calculate the number of error correction symbols. Must be even.\r\n        const ecSymbols = (received.length - offset - dataLength) & (~1);\r\n\r\n        // Correct potential errors.\r\n        let corrected: Uint8ClampedArray;\r\n        if (ecSymbols !== 0) {\r\n            const rsDecoder = new ReedSolomonDecoder(BinaryGF.BINARY_GF_6);\r\n            // ReedSolomonDecoder will throw errors if the correction process fails, when either the\r\n            // error locations are computed incorrectly, or the number of errors is above the limit.\r\n            try {\r\n                corrected = rsDecoder.decode(received, ecSymbols);\r\n            } catch (e) {\r\n                throw new Error(\"Invalid IChing Code!\");\r\n            }\r\n        } else {\r\n            corrected = received.slice();\r\n        }\r\n\r\n        // This check is useful when most symbols are altered to zeroes, which will result in a\r\n        // wrong correction that passes the ReedSolomonDecoder checks, but will alter the metadata\r\n        // symbols to wrong values.\r\n        for (let i = 0; i < offset; i++) {\r\n            if (corrected[i] !== received[i]) {\r\n                throw new Error(\"Invalid IChing Code!\");\r\n            }\r\n        }\r\n\r\n        // Convert corrected data to string.\r\n        const alphabet = Encoder.ALPHABET;\r\n        let payload: string = \"\";\r\n        for (let i = 0; i < dataLength; i++) {\r\n            if (corrected[offset + i] >= alphabet.length) {\r\n                throw new Error(\"Invalid IChing Code!\");\r\n            }\r\n\r\n            payload += alphabet[corrected[offset + i]];\r\n        }\r\n\r\n        return {\r\n            version,\r\n            size,\r\n            data: payload,\r\n            patterns: null,\r\n        };\r\n    }\r\n}\r\n","import { BinaryGFPoly } from \"./BinaryGFPoly\";\r\n\r\n/**\r\n * This class implements mathematical operations over binary Galois Fields using the provided\r\n * primitive polynomial.\r\n *\r\n * @see [Wikipedia's page]{@link https://en.wikipedia.org/wiki/Finite_field} for more info.\r\n * @export\r\n * @class BinaryGF\r\n */\r\nexport class BinaryGF {\r\n    /**\r\n     * 6th degree polynomial x^6 + x + 1.\r\n     */\r\n    public static PRIMITIVE_DEGREE_6: number = 0x43;\r\n    /**\r\n     * GF(2^6).\r\n     */\r\n    public static BINARY_GF_6: BinaryGF = new BinaryGF(BinaryGF.PRIMITIVE_DEGREE_6, 6);\r\n    /**\r\n     * Upper limit on the size of the Galois Field GF(2^m).\r\n     */\r\n    public static M_LIMIT: number = 8;\r\n\r\n    private size: number;\r\n    private primitive: number;\r\n    private expTable: Uint8ClampedArray;\r\n    private logTable: Uint8ClampedArray;\r\n    private zeroPoly: BinaryGFPoly;\r\n    private onePoly: BinaryGFPoly;\r\n\r\n    /**\r\n     * Creates a new GF(2^m).\r\n     *\r\n     * @param {number} primitive - Irreducible polynomial of degree m.\r\n     * @param {number} m - Exponent determining the size of the GF(2^m).\r\n     * @throws Will throw an Error if m is bigger than the internal limit of 16.\r\n     */\r\n    public constructor(primitive: number, m: number) {\r\n        if (m < 1 || m > BinaryGF.M_LIMIT) {\r\n            throw new Error(\"Illegal value of Galois Field size!\");\r\n        }\r\n\r\n        this.size = 1 << m;\r\n        this.primitive = primitive;\r\n        this.expTable = new Uint8ClampedArray(this.size);\r\n        this.logTable = new Uint8ClampedArray(this.size);\r\n\r\n        // Build exponent and log tables.\r\n        let x = 1;\r\n        for (let i = 0; i < this.size; i++) {\r\n            this.expTable[i] = x;\r\n            this.logTable[x] = i;\r\n            // By convention, generator number alpha is equal to 2.\r\n            x <<= 1;\r\n            // if x >= 2^m: x %= primitive.\r\n            if (x & this.size) {\r\n                x ^= this.primitive;\r\n            }\r\n        }\r\n\r\n        this.zeroPoly = new BinaryGFPoly(this, new Uint8ClampedArray([0]));\r\n        this.onePoly = new BinaryGFPoly(this, new Uint8ClampedArray([1]));\r\n    }\r\n\r\n    /**\r\n     * Returns the size of the instance's Galois Field.\r\n     *\r\n     * @returns {number}\r\n     */\r\n    public getSize(): number {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Raises 2 to the power of x in GF(2^m).\r\n     *\r\n     * @param {number} x - Exponent.\r\n     * @returns {number} 2 to the power of x in GF(2^m).\r\n     */\r\n    public exp(x: number): number {\r\n        return this.expTable[x];\r\n    }\r\n\r\n    /**\r\n     * Returns the base 2 log of x in GF(2^m).\r\n     *\r\n     * @param {number} x - integer.\r\n     * @returns {number} base 2 log of x in GF(2^m).\r\n     */\r\n    public log(x: number): number {\r\n        if (x === 0) {\r\n            throw new Error(\"Log(0) is not defined in Galois Fields!\");\r\n        }\r\n        return this.logTable[x];\r\n    }\r\n\r\n    /**\r\n     * Returns the polynomial 0.\r\n     *\r\n     * @returns {BinaryGFPoly}\r\n     */\r\n    public getZeroPoly(): BinaryGFPoly {\r\n        return this.zeroPoly;\r\n    }\r\n\r\n    /**\r\n     * Returns the polynomial 1.\r\n     *\r\n     * @returns {BinaryGFPoly}\r\n     */\r\n    public getOnePoly(): BinaryGFPoly {\r\n        return this.onePoly;\r\n    }\r\n\r\n    /**\r\n     * Creates the monomial coefficient * x^degree.\r\n     *\r\n     * @param {number} degree\r\n     * @param {number} coefficient\r\n     * @returns {BinaryGFPoly} coefficient * x^degree.\r\n     * @throws Will throw an error if degree is negative.\r\n     */\r\n    public buildMonomial(degree: number, coefficient: number): BinaryGFPoly {\r\n        if (degree < 0) {\r\n            throw new Error(\"Monomial degree must be non-negative!\");\r\n        }\r\n\r\n        const coefficients = new Uint8ClampedArray(degree + 1);\r\n        coefficients[0] = coefficient;\r\n        return new BinaryGFPoly(this, coefficients);\r\n    }\r\n\r\n    /**\r\n     * Adds two numbers in GF(2^m).\r\n     *\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @returns {number} x + y in GF(2^m).\r\n     */\r\n    public add(x: number, y: number): number {\r\n        return x ^ y;\r\n    }\r\n\r\n    /**\r\n     * Multiplies two numbers in GF(2^m).\r\n     *\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @returns {number} x * y in GF(2^m).\r\n     */\r\n    public multiply(x: number, y: number): number {\r\n        if (x === 0 || y === 0) {\r\n            return 0;\r\n        }\r\n        return this.expTable[(this.logTable[x] + this.logTable[y]) % (this.size - 1)];\r\n    }\r\n\r\n    /**\r\n     * Calculates the multiplicative inverse of a number in GF(2^m).\r\n     *\r\n     * @param {number} x\r\n     * @returns {number} 1 / x in GF(2^m).\r\n     * @throws Will throw an error if argument is zero.\r\n     */\r\n    public mulInverse(x: number): number {\r\n        if (x === 0) {\r\n            throw new Error(\"0 has no multiplicative inverse!\");\r\n        }\r\n        return this.expTable[this.size - 1 - this.logTable[x]];\r\n    }\r\n\r\n    /**\r\n     * Divides two numbers in GF(2^m).\r\n     *\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @returns {number} x / y in GF(2^m).\r\n     * @throws Will throw an error in case of division by zero.\r\n     */\r\n    public divide(x: number, y: number): number {\r\n        if (y === 0) {\r\n            throw new Error(\"Division by zero!\");\r\n        }\r\n        return this.multiply(x, this.mulInverse(y));\r\n    }\r\n}\r\n","import { BinaryGF } from \"./BinaryGF\";\r\nimport { BinaryGFPoly } from \"./BinaryGFPoly\";\r\n\r\n/**\r\n * This class implements Reed-Solomon encoding.\r\n *\r\n * @see [this guide]{@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders}\r\n * for more info.\r\n * @export\r\n * @class ReedSolomonEncoder\r\n */\r\nexport class ReedSolomonEncoder {\r\n    private field: BinaryGF;\r\n    private generators: BinaryGFPoly[];\r\n\r\n    /**\r\n     * Creates a Reed-Solomon encoder for the given binary Galois Field.\r\n     *\r\n     * @param {BinaryGF} field - BinaryGF the encoder works in.\r\n     */\r\n    public constructor(field: BinaryGF) {\r\n        this.field = field;\r\n        this.generators = [field.getOnePoly()];\r\n    }\r\n\r\n    /**\r\n     * Encodes the given data with the given number of error correction symbols.\r\n     *\r\n     * @param {Uint8ClampedArray} data - Data to be encoded.\r\n     * @param {number} ecSymbols - Number of error symbols.\r\n     * @returns {Uint8ClampedArray} Encoded data.\r\n     * @throws Will throw an error if data is empty.\r\n     */\r\n    public encode(data: Uint8ClampedArray, ecSymbols: number): Uint8ClampedArray {\r\n        if (data.length === 0) {\r\n            throw new Error(\"No data symbols!\");\r\n        }\r\n\r\n        // No error correction symbols to be appended.\r\n        if (ecSymbols === 0) {\r\n            return new Uint8ClampedArray(data);\r\n        }\r\n\r\n        // Get generator polynomial of degree = ecSymbols.\r\n        const generator = this.getGenerator(ecSymbols);\r\n\r\n        // Pad the data with zeroes.\r\n        const encodedData = new Uint8ClampedArray(data.length + ecSymbols);\r\n        encodedData.set(data);\r\n        const encodedDataPoly = new BinaryGFPoly(this.field, encodedData);\r\n\r\n        // Remainder of encodedDataPoly / generator is the error correction symbols.\r\n        const remainderPoly = encodedDataPoly.dividePoly(generator)[1];\r\n        const remainderCoefficients = remainderPoly.getCoefficients();\r\n\r\n        // Append error correction symbols and return.\r\n        encodedData.set(remainderCoefficients, encodedData.length - remainderCoefficients.length);\r\n        return encodedData;\r\n    }\r\n\r\n    /**\r\n     * Returns an irreducible polynomial of the desired degree.\r\n     * Polynomial is the product of factors (x - a^i) for i: 0 -> d - 1,\r\n     * where d is the degree and a is the Galois Field generator number alpha.\r\n     *\r\n     * @param {number} degree - degree of polynomial.\r\n     * @returns {BinaryGFPoly} generator polynomial of the desired degree.\r\n     */\r\n    private getGenerator(degree: number): BinaryGFPoly {\r\n        for (let d = this.generators.length; d <= degree; d++) {\r\n            this.generators.push(this.generators[d - 1].multiplyPoly(\r\n                new BinaryGFPoly(\r\n                    this.field, new Uint8ClampedArray([1, this.field.exp(d - 1)]),\r\n                ),\r\n            ));\r\n        }\r\n        return this.generators[degree];\r\n    }\r\n}\r\n","import { BinaryGF } from \"./BinaryGF\";\r\nimport { BinaryGFPoly } from \"./BinaryGFPoly\";\r\n\r\n/**\r\n * This class implements Reed-Solomon decoding.\r\n *\r\n * @see [this guide]{@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders}\r\n * for more info.\r\n * @export\r\n * @class ReedSolomonDecoder\r\n */\r\nexport class ReedSolomonDecoder {\r\n    private field: BinaryGF;\r\n\r\n    /**\r\n     * Creates a Reed-Solomon decoder for the given binary Galois Field.\r\n     *\r\n     * @param {BinaryGF} field - BinaryGF the encoder works in.\r\n     */\r\n    public constructor(field: BinaryGF) {\r\n        this.field = field;\r\n    }\r\n\r\n    /**\r\n     * Corrects errors in the received data, up to ecSymbols / 2 errors.\r\n     *\r\n     * @param {Uint8ClampedArray} received - Data to be decoded/corrected.\r\n     * @param {number} ecSymbols - number of error correction symbols.\r\n     * @returns {Uint8ClampedArray} corrected data.\r\n     * @throws Will throw an error if the decoding process fails.\r\n     */\r\n    public decode(received: Uint8ClampedArray, ecSymbols: number): Uint8ClampedArray {\r\n        // Convert received data into a polynomial.\r\n        const receivedPoly = new BinaryGFPoly(this.field, received);\r\n\r\n        // Compute syndromes polynomial and return in case of no errors.\r\n        const syndromes = this.computeSyndromes(receivedPoly, ecSymbols);\r\n        if (syndromes.isZero()) {\r\n            return new Uint8ClampedArray(received);\r\n        }\r\n\r\n        // Compute error locator and error evaluator polynomials.\r\n        const [errorLocator, errorEvaluator] = this.computeLocatorAndEvaluator(\r\n            syndromes, ecSymbols,\r\n        );\r\n\r\n        // Compute error locator roots and error magnitudes.\r\n        const errorLocations = this.computeErrorLocations(errorLocator);\r\n        const errorMagnitudes = this.computeErrorMagnitudes(errorEvaluator, errorLocations);\r\n\r\n        // Correct the errors.\r\n        const corrected = new Uint8ClampedArray(received);\r\n        for (let i = 0; i < errorLocations.length; i++) {\r\n            const position = corrected.length - 1 - this.field.log(errorLocations[i]);\r\n            // Sanity check.\r\n            if (position < 0) {\r\n                throw new Error(\"Invalid error location\");\r\n            }\r\n\r\n            corrected[position] = this.field.add(corrected[position], errorMagnitudes[i]);\r\n        }\r\n\r\n        return corrected;\r\n    }\r\n\r\n    /**\r\n     * Computes the syndromes polynomial from the given received data and the number of error\r\n     * correction symbols.\r\n     *\r\n     * @param {BinaryGFPoly} poly - received data polynomial.\r\n     * @param {number} ecSymbols - number of error correction symbols.\r\n     * @returns {BinaryGFPoly} Syndromes polynomial.\r\n     */\r\n    private computeSyndromes(poly: BinaryGFPoly, ecSymbols: number): BinaryGFPoly {\r\n        const coefficients = new Uint8ClampedArray(ecSymbols);\r\n        for (let i = 0; i < ecSymbols; i++) {\r\n            coefficients[ecSymbols - 1 - i] = poly.evaluateAt(this.field.exp(i));\r\n        }\r\n        return new BinaryGFPoly(this.field, coefficients);\r\n    }\r\n\r\n    /**\r\n     * Computes the error locator and error evaluator polynomials, given the syndromes polynomials\r\n     * and the number of error correction symbols. Uses an adaptation of the Extended Euclidean\r\n     * Theorem.\r\n     *\r\n     * @see [this]{@link https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction} for\r\n     * more info.\r\n     * @param {BinaryGFPoly} syndromes\r\n     * @param {number} ecSymbols\r\n     * @returns {BinaryGFPoly[]} [errorLocator, errorEvaluator]\r\n     */\r\n    private computeLocatorAndEvaluator(syndromes: BinaryGFPoly, ecSymbols: number): BinaryGFPoly[] {\r\n        let R2 = this.field.buildMonomial(ecSymbols, 1);\r\n        let R1 = syndromes;\r\n        let A2 = this.field.getZeroPoly();\r\n        let A1 = this.field.getOnePoly();\r\n\r\n        while (R1.getDegree() >= ecSymbols / 2) {\r\n            const Q = R2.dividePoly(R1)[0];\r\n            const R0 = R2.add(Q.multiplyPoly(R1));\r\n            const A0 = A2.add(Q.multiplyPoly(A1));\r\n\r\n            R2 = R1;\r\n            R1 = R0;\r\n            A2 = A1;\r\n            A1 = A0;\r\n        }\r\n\r\n        const constant = A1.getCoefficient(0);\r\n        const inverseConstant = this.field.mulInverse(constant);\r\n        const errorLocator = A1.multiplyScalar(inverseConstant);\r\n        const errorEvaluator = R1.multiplyScalar(inverseConstant);\r\n\r\n        return [errorLocator, errorEvaluator];\r\n    }\r\n\r\n    /**\r\n     * Computes the roots of the error locator polynomial using an exhaustive search. This is\r\n     * possible because the number of elements of a binary Galois Field is limited. A possible\r\n     * optimisation would be implementing Chien's search for a faster exhaustive search.\r\n     *\r\n     * @param {BinaryGFPoly} errorLocator\r\n     * @returns {Uint8ClampedArray}\r\n     * @throws Will throw an error if the error locator degree does not match the number of roots.\r\n     */\r\n    private computeErrorLocations(errorLocator: BinaryGFPoly): Uint8ClampedArray {\r\n        const errorCount = errorLocator.getDegree();\r\n        const locations = [];\r\n\r\n        // Exhaustive search for the roots.\r\n        let e = 0;\r\n        for (let i = 1; i < this.field.getSize(); i++) {\r\n            if (errorLocator.evaluateAt(i) === 0) {\r\n                e++;\r\n                locations.push(this.field.mulInverse(i));\r\n            }\r\n        }\r\n\r\n        // Sanity check.\r\n        if (e !== errorCount) {\r\n            throw new Error(\"Error locator degree does not match number of roots!\");\r\n        }\r\n\r\n        return new Uint8ClampedArray(locations);\r\n    }\r\n\r\n    /**\r\n     * Computes the error magnitudes from the error evaluator polynomial and the computed error\r\n     * locations. This is an application of Forney's algorithm.\r\n     *\r\n     * @see [this link]{@link https://en.wikipedia.org/wiki/Forney_algorithm} for further info.\r\n     * @param {BinaryGFPoly} errorEvaluator\r\n     * @param {Uint8ClampedArray} errorLocations\r\n     * @returns {Uint8ClampedArray} error magnitudes.\r\n     */\r\n    private computeErrorMagnitudes(\r\n        errorEvaluator: BinaryGFPoly, errorLocations: Uint8ClampedArray,\r\n    ): Uint8ClampedArray {\r\n        const errorCount = errorLocations.length;\r\n        const magnitudes = new Uint8ClampedArray(errorCount);\r\n\r\n        for (let i = 0; i < errorCount; i++) {\r\n            const xiInverse = this.field.mulInverse(errorLocations[i]);\r\n            let denominator = 1;\r\n\r\n            for (let j = 0; j < errorCount; j++) {\r\n                if (i === j) {\r\n                    continue;\r\n                }\r\n\r\n                const term = this.field.add(1, this.field.multiply(xiInverse, errorLocations[j]));\r\n                denominator = this.field.multiply(denominator, term);\r\n            }\r\n\r\n            magnitudes[i] = this.field.multiply(\r\n                errorEvaluator.evaluateAt(xiInverse), this.field.mulInverse(denominator),\r\n            );\r\n        }\r\n\r\n        return magnitudes;\r\n    }\r\n}\r\n","export { Extractor } from \"./Extractor\";\r\n","import { BitMatrix } from \"../../BitMatrix\";\r\nimport { Encoder } from \"../../encoder/Encoder\";\r\nimport { Writer } from \"../../encoder/writer\";\r\nimport { Point } from \"../../geometry\";\r\nimport { sumArray } from \"../../utils\";\r\nimport { PatternLocator } from \"../locator/PatternLocator\";\r\n\r\n/**\r\n * This class extracts raw data from a perspective corrected binary image,\r\n * represented as a BitMatrix.\r\n *\r\n * @export\r\n * @class Extractor\r\n */\r\nexport class Extractor {\r\n    /**\r\n     * Maximum relative error tolerated in the ratios of the finder patterns.\r\n     */\r\n    public static FINDER_ERROR_THRESHOLD = 0.2;\r\n    /**\r\n     * Percentage of black pixels that should be present in the left or right border of the box\r\n     * around the symbol area for it to be considered inside the symbol.\r\n     */\r\n    public static VERTICAL_BORDER_BLACK_THRESHOLD = 0.25;\r\n    /**\r\n     * Percentage of black pixels that should be present in a horizontal line for it to be\r\n     * considered part of a valid bit in a symbol.\r\n     */\r\n    public static LINE_VALID_BLACK_THRESHOLD = 0.5;\r\n    /**\r\n     * Percentage of black pixels that should be present in a horizontal line for it to be\r\n     * considered part of a one-bit.\r\n     */\r\n    public static LINE_ONE_BLACK_THRESHOLD = 0.8;\r\n    /**\r\n     * Percentage of the size of the gap between symbols that should be exceeded for a gap\r\n     * to be considered valid.\r\n     */\r\n    public static GAP_DIM_THRESHOLD = 0.67;\r\n    /**\r\n     * Percentage the size of a unit that should be exceeded for a unit to be considered valid.\r\n     * A unit is equivalent to the height of a single bit in a symbol.\r\n     */\r\n    public static UNIT_DIM_THRESHOLD = 0.5;\r\n\r\n    /**\r\n     * Hotrizontal line that is not part of any bits.\r\n     */\r\n    public static LINE_STATE_INVALID = -1;\r\n    /**\r\n     * Horizontal line that is part of a zero-bit.\r\n     */\r\n    public static LINE_STATE_ZERO = 0;\r\n    /**\r\n     * Horizontal line that is part of a one-bit.\r\n     */\r\n    public static LINE_STATE_ONE = 1;\r\n\r\n    // Scale of image, relative to base dimensions.\r\n    private scale: number;\r\n\r\n    /**\r\n     * Main class method. Extracts encoded data from the given perspective corrected binary image.\r\n     *\r\n     * @param {BitMatrix} matrix - Binary image represented as bits.\r\n     * @returns {Uint8ClampedArray} - Extracted data.\r\n     */\r\n    public extract(matrix: BitMatrix): Uint8ClampedArray {\r\n        const imgWidth = matrix.width;\r\n        const imgHeight = matrix.height;\r\n\r\n        // Initial scale estimation to get code dimensions.\r\n        this.scale = this.estimateScale(matrix);\r\n        let scaledUnitDim = Writer.UNIT_DIM * this.scale;\r\n        let scaledSymbolDim = Writer.SYMBOL_DIM * this.scale;\r\n        let scaledGapDim = Writer.GAP_DIM * this.scale;\r\n        let scaledFinderRadius = Writer.FINDER_OUTER_RADIUS * this.scale;\r\n\r\n        // Estimate width and height of code, in symbols.\r\n        const cols = Math.round((imgWidth + scaledGapDim - scaledSymbolDim) /\r\n            (scaledGapDim + scaledSymbolDim));\r\n        const rows = Math.round((imgHeight + scaledGapDim - scaledSymbolDim) /\r\n            (scaledGapDim + scaledSymbolDim));\r\n\r\n        if (cols !== rows) {\r\n            throw new Error(\"IChing code must be a square!\");\r\n        }\r\n\r\n        // More accurate scale estimation based on total image dimensions,\r\n        // and estimated code dimensions.\r\n        const baseDimension = (rows + 1) * Writer.SYMBOL_DIM + (rows - 1) * Writer.GAP_DIM;\r\n        this.scale = (matrix.width + matrix.height) / baseDimension / 2;\r\n        scaledUnitDim = Writer.UNIT_DIM * this.scale;\r\n        scaledSymbolDim = Writer.SYMBOL_DIM * this.scale;\r\n        scaledGapDim = Writer.GAP_DIM * this.scale;\r\n        scaledFinderRadius = Writer.FINDER_OUTER_RADIUS * this.scale;\r\n\r\n        const data = new Uint8ClampedArray(rows * cols);\r\n\r\n        // Column-by-column vertical scan.\r\n        for (let col = 0; col < cols; col++) {\r\n            // Initial estimated coordinates for the first symbol in the column.\r\n            let estimateX1 = Math.round(scaledFinderRadius +\r\n                col * (scaledSymbolDim + scaledGapDim));\r\n            let estimateX2 = Math.round(estimateX1 + scaledSymbolDim);\r\n            let estimateY1 = Math.round(scaledFinderRadius);\r\n            let estimateY2 = Math.round(estimateY1 + scaledSymbolDim);\r\n\r\n            for (let row = 0; row < rows; row++) {\r\n                // Y-coordinate of scanned line. Starts before estimate, for safety.\r\n                let scanY = Math.max(0, Math.round(estimateY1 - scaledUnitDim));\r\n\r\n                // Fix potential horizontal shift resulting from distortion.\r\n                const horizontalShift = this.fixHorizontalShift(matrix,\r\n                    estimateX1, estimateY1, estimateX2, estimateY2);\r\n\r\n                // Symbol coordinates bookkeeping.\r\n                const actualX1 = horizontalShift[0];\r\n                const actualX2 = horizontalShift[1];\r\n                let actualY1 = estimateY1;\r\n                let actualY2 = estimateY2;\r\n\r\n                // Scanned line states bookkeeping.\r\n                let endOfSymbol: boolean = false;\r\n                let oldState = Extractor.LINE_STATE_INVALID;\r\n                let oldStateCount = 0;\r\n                let oldStateStartY = scanY;\r\n\r\n                // Symbol data bookkeeping.\r\n                let bitsFound = 0;\r\n                let mask = (1 << Writer.BITS_PER_SYMBOL) - 1;\r\n\r\n                const searchYLimit = Math.min(matrix.height, Math.round(estimateY2 + scaledGapDim));\r\n\r\n                while (scanY < searchYLimit && !endOfSymbol) {\r\n                    const newState = this.getHorizontalState(matrix, actualX1, actualX2, scanY);\r\n                    if (newState === oldState) { // Same state.\r\n                        oldStateCount++;\r\n                    } else { // Different state.\r\n                        // Check if old state is a valid bit.\r\n                        if (oldState !== Extractor.LINE_STATE_INVALID &&\r\n                        oldStateCount / scaledUnitDim > Extractor.UNIT_DIM_THRESHOLD) {\r\n                            if (bitsFound >= Writer.BITS_PER_SYMBOL) {\r\n                                bitsFound--;\r\n                                // If we discovered extra bit, consider the last bit found was\r\n                                // false positive and reset it to be replaced with this new bit.\r\n                                mask = (mask >> 1) | (1 << bitsFound);\r\n                            }\r\n                            // Apply the new bit to the mask, basically turn of the bit if\r\n                            // it was a 0-bit, by anding with `1..1x1..1`, `x` is the new bit\r\n                            mask &= ~((1 - oldState) << bitsFound);\r\n                            bitsFound++;\r\n\r\n                            // If first bit of the symbol, store the y-coordinate\r\n                            // of the top of the symbol.\r\n                            if (bitsFound === 1) {\r\n                                actualY1 = oldStateStartY;\r\n                            }\r\n                        }\r\n\r\n                        oldState = newState;\r\n                        oldStateCount = 1;\r\n                        oldStateStartY = scanY;\r\n                    }\r\n\r\n                    // Check if a gap is detected\r\n                    if (oldState === Extractor.LINE_STATE_INVALID &&\r\n                    oldStateCount / scaledGapDim > Extractor.GAP_DIM_THRESHOLD) {\r\n                        // If inside symbol, assume missing bit.\r\n                        if (oldStateStartY <= Math.round(estimateY2 - scaledUnitDim)) {\r\n                            bitsFound++;\r\n                            // If first bit of the symbol, store the y-coordinate\r\n                            // of the top of the symbol.\r\n                            if (bitsFound === 1) {\r\n                                actualY1 = Math.round(oldStateStartY + scaledUnitDim);\r\n                            }\r\n\r\n                            oldStateStartY = scanY + 1;\r\n                            oldStateCount = 0;\r\n                        // Else, symbol ended.\r\n                        } else {\r\n                            endOfSymbol = true;\r\n                        }\r\n                    }\r\n\r\n                    scanY++;\r\n                }\r\n\r\n                // if the loop was exited due to reaching the search limit, reset scanY for next\r\n                // symbol, and don't change actualY2 from estimate.\r\n                if (scanY === searchYLimit) {\r\n                    scanY -= Math.round(scaledUnitDim);\r\n                // else, adjust it.\r\n                } else {\r\n                    actualY2 = oldStateStartY;\r\n                }\r\n\r\n                // If version number is wrong, throw error and don't continue extraction.\r\n                if (row === 0 && col === 0 && mask !== Encoder.VERSION) {\r\n                    throw new Error(\"Invalid IChing code!\");\r\n                }\r\n\r\n                // If payload length is invalid, throw error and don't continue extraction.\r\n                if (row === 0 && col === 1 && mask + Encoder.OFFSET > rows * cols) {\r\n                    throw new Error(\"Invalid IChing code!\");\r\n                }\r\n\r\n                data[row * cols + col] = mask;\r\n\r\n                // Calculate estimated coordinates for the next symbol based on the current one.\r\n                estimateX1 = actualX1;\r\n                estimateX2 = actualX2;\r\n                estimateY1 = Math.round(actualY2 + scaledGapDim);\r\n                estimateY2 = Math.round(estimateY1 + scaledSymbolDim);\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Estimates a scale of the input image relative to the default IChing image resolution, based\r\n     * on the average radius of the finder patterns.\r\n     *\r\n     * @param {BitMatrix} matrix - binary image represented as bits.\r\n     * @returns {number} estimated scale.\r\n     */\r\n    private estimateScale(matrix: BitMatrix): number {\r\n        let sum = 0;\r\n        let count = 0;\r\n        let state;\r\n\r\n        // Top-left finder, horizontal.\r\n        state = this.scanFinderRadius(matrix, { x: 0, y: 0 }, 1, 0);\r\n        if (this.isValidFinderRadius(state)) {\r\n            sum += state[0] + state[1] + state[2];\r\n            count++;\r\n        }\r\n\r\n        // Top-left finder, vertical.\r\n        state = this.scanFinderRadius(matrix, { x: 0, y: 0 }, 0, 1);\r\n        if (this.isValidFinderRadius(state)) {\r\n            sum += state[0] + state[1] + state[2];\r\n            count++;\r\n        }\r\n\r\n        // Top-left finder, diagonal.\r\n        state = this.scanFinderRadius(matrix, { x: 0, y: 0 }, 1, 1);\r\n        if (this.isValidFinderRadius(state)) {\r\n            sum += (state[0] + state[1] + state[2]) * PatternLocator.SQRT2;\r\n            count++;\r\n        }\r\n\r\n        // Bottom-left finder, horizontal.\r\n        state = this.scanFinderRadius(matrix, { x: 0, y: matrix.height - 1 }, 1, 0);\r\n        if (this.isValidFinderRadius(state)) {\r\n            sum += state[0] + state[1] + state[2];\r\n            count++;\r\n        }\r\n\r\n        // Bottom-left finder, vertical.\r\n        state = this.scanFinderRadius(matrix, { x: 0, y: matrix.height - 1 }, 0, -1);\r\n        if (this.isValidFinderRadius(state)) {\r\n            sum += state[0] + state[1] + state[2];\r\n            count++;\r\n        }\r\n\r\n        // Bottom-left finder, diagonal.\r\n        state = this.scanFinderRadius(matrix, { x: 0, y: matrix.height - 1 }, 1, -1);\r\n        if (this.isValidFinderRadius(state)) {\r\n            sum += (state[0] + state[1] + state[2]) * PatternLocator.SQRT2;\r\n            count++;\r\n        }\r\n\r\n        // Top-right finder, horizontal.\r\n        state = this.scanFinderRadius(matrix, { x: matrix.width - 1, y: 0 }, -1, 0);\r\n        if (this.isValidFinderRadius(state)) {\r\n            sum += state[0] + state[1] + state[2];\r\n            count++;\r\n        }\r\n\r\n        // Top-right finder, vertical.\r\n        state = this.scanFinderRadius(matrix, { x: matrix.width - 1, y: 0 }, 0, 1);\r\n        if (this.isValidFinderRadius(state)) {\r\n            sum += state[0] + state[1] + state[2];\r\n            count++;\r\n        }\r\n\r\n        // Top-right finder, diagonal.\r\n        state = this.scanFinderRadius(matrix, { x: matrix.width - 1, y: 0 }, -1, 1);\r\n        if (this.isValidFinderRadius(state)) {\r\n            sum += (state[0] + state[1] + state[2]) * PatternLocator.SQRT2;\r\n            count++;\r\n        }\r\n\r\n        if (count === 0) {\r\n            throw new Error(\"No valid finder patterns found!\");\r\n        }\r\n\r\n        const averageRadius = (sum - count) / count;\r\n        const estimatedScale = averageRadius / Writer.FINDER_OUTER_RADIUS;\r\n\r\n        return estimatedScale;\r\n    }\r\n\r\n    /**\r\n     * Returns the radius of the finder pattern, given its centre and a scanning direction,\r\n     * horizontal or vertical.\r\n     *\r\n     * @param {BitMatrix} matrix - binary image represented as bits.\r\n     * @param {Point} centre\r\n     * @param {number} dx\r\n     * @param {number} dy\r\n     * @returns {number[]} [black, white, black] count of pixels.\r\n     */\r\n    private scanFinderRadius(matrix: BitMatrix, centre: Point, dx: number, dy: number): number[] {\r\n        if (Math.abs(dx) > 1 || Math.abs(dy) > 1 || (dx === 0 && dy === 0)) {\r\n            throw new Error(\"Invalid scanning direction\");\r\n        }\r\n\r\n        let state = 0;\r\n        const count = [0, 0, 0];\r\n        let x = centre.x;\r\n        let y = centre.y;\r\n\r\n        // From the centre of the pattern, we should pass by 3 states:\r\n        // { 0: black, 1: white, 2: black }.\r\n        while (\r\n            x >= 0 && x < matrix.width &&\r\n            y >= 0 && y < matrix.height\r\n        ) {\r\n            // If white in even state, or black in odd state, increment state.\r\n            if ((state & 1) === matrix.get(x, y)) {\r\n                state++;\r\n            }\r\n            if (state === 3) {\r\n                break;\r\n            }\r\n\r\n            count[state]++;\r\n            x += dx;\r\n            y += dy;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Checks if the provided pixel count represent the proper ratios expected in a finder pattern.\r\n     * Finder patterns have a black:white:black:white:black ratio of 1:1:3:1:1, so the radius should\r\n     * have a black:white:black ratio of 1.5:1:1.\r\n     *\r\n     * @private\r\n     * @param {number[]} count\r\n     * @returns {boolean}\r\n     */\r\n    private isValidFinderRadius(count: number[]): boolean {\r\n        if (count.length !== 3 || count[0] === 0 || count[1] === 0 || count[2] === 0) {\r\n            return false;\r\n        }\r\n\r\n        const baseDimensions = [\r\n            Writer.FINDER_INNER_RADIUS,\r\n            Writer.FINDER_MIDDLE_RADIUS - Writer.FINDER_INNER_RADIUS,\r\n            Writer.FINDER_OUTER_RADIUS - Writer.FINDER_MIDDLE_RADIUS,\r\n        ];\r\n        const averageUnit = sumArray(count) / sumArray(baseDimensions);\r\n        // the maximum error that we can tolerate for each unit.\r\n        const maxVariance = averageUnit / 3;\r\n\r\n        // then we check that each state contains the needed pixels.\r\n        let validPattern = true;\r\n        for (let i = 0; i < baseDimensions.length; ++i) {\r\n            if (\r\n                Math.abs(count[i] - averageUnit * baseDimensions[i]) >\r\n                baseDimensions[i] * maxVariance\r\n            ) {\r\n                validPattern = false;\r\n            }\r\n        }\r\n        return validPattern;\r\n    }\r\n\r\n    /**\r\n     * Takes coordinates representing a sub-rectangle of the image containing an IChing symbol,\r\n     * and fixes the horizontal shift, if any, in the left and right borders of the sub-rectangle.\r\n     *\r\n     * @param {BitMatrix} matrix - binary image represented as bits.\r\n     * @param {number} x1\r\n     * @param {number} y1\r\n     * @param {number} x2\r\n     * @param {number} y2\r\n     * @returns {number[]} [fixed x1, fixed x2]\r\n     */\r\n    private fixHorizontalShift(\r\n        matrix: BitMatrix, x1: number, y1: number, x2: number, y2: number,\r\n    ): number[] {\r\n        const threshold = Extractor.VERTICAL_BORDER_BLACK_THRESHOLD;\r\n        const boxHeight = y2 - y1 + 1;\r\n        const width = matrix.width;\r\n        const originalX1 = x1;\r\n        const originalX2 = x2;\r\n\r\n        const maxDiff = Math.round((x2 - x1) / 2);\r\n        const leftLimit = Math.max(0, originalX1 - maxDiff);\r\n        const rightLimit = Math.min(matrix.width - 1, originalX2 + maxDiff);\r\n\r\n        // Fix left border.\r\n        while (\r\n            x1 > leftLimit &&\r\n            this.countBlackInLine(matrix, x1, y1, x1, y2) / boxHeight > threshold\r\n        ) {\r\n            x1--;\r\n        }\r\n        while (\r\n            x1 < rightLimit &&\r\n            this.countBlackInLine(matrix, x1, y1, x1, y2) / boxHeight < threshold\r\n        ) {\r\n            x1++;\r\n        }\r\n\r\n        // Fix right border.\r\n        while (\r\n            x2 < rightLimit &&\r\n            this.countBlackInLine(matrix, x2, y1, x2, y2) / boxHeight > threshold\r\n        ) {\r\n            x2++;\r\n        }\r\n        while (\r\n            x2 > leftLimit &&\r\n            this.countBlackInLine(matrix, x2, y1, x2, y2) / boxHeight < threshold\r\n        ) {\r\n            x2--;\r\n        }\r\n\r\n        // If symbol is missing too many bits or is empty, return the original estimate becuase\r\n        // the fix is not valid.\r\n        if (x2 <= x1 || x1 === leftLimit || x2 === rightLimit) {\r\n            return [originalX1, originalX2];\r\n        }\r\n\r\n        return [x1, x2];\r\n    }\r\n\r\n    /**\r\n     * Counts the number of black and white pixels in a vertical or horizontal line.\r\n     *\r\n     * @param {BitMatrix} matrix - binary image represented as bits.\r\n     * @param {number} x1\r\n     * @param {number} y1\r\n     * @param {number} x2\r\n     * @param {number} y2\r\n     * @returns {number} count of black pixels in given line.\r\n     */\r\n    private countBlackInLine(\r\n        matrix: BitMatrix, x1: number, y1: number, x2: number, y2: number,\r\n    ): number {\r\n        if (x1 !== x2 && y1 !== y2) {\r\n            throw new Error(\"Line must be horizontal or vertical!\");\r\n        }\r\n\r\n        let count: number = 0;\r\n        for (let x = x1; x <= x2; x++) {\r\n            for (let y = y1; y <= y2; y++) {\r\n                count += matrix.get(x, y);\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Checks if the given horizontal line belongs to one of the bits of an IChing symbol,\r\n     * and if so, whether it is a zero or a one.\r\n     *\r\n     * @param {BitMatrix} matrix - binary image represented as bits.\r\n     * @param {number} x1\r\n     * @param {number} y1\r\n     * @param {number} x2\r\n     * @param {number} y2\r\n     * @returns {number} one of the three LINE_STATE constants.\r\n     */\r\n    private getHorizontalState(matrix: BitMatrix, x1: number, x2: number, y: number): number {\r\n        const lineWidth = x2 - x1 + 1;\r\n        const black = this.countBlackInLine(matrix, x1, y, x2, y);\r\n\r\n        // Check if the line belongs to one of the black lines of an IChing symbol.\r\n        if (black / lineWidth < Extractor.LINE_VALID_BLACK_THRESHOLD) {\r\n            return Extractor.LINE_STATE_INVALID;\r\n        }\r\n\r\n        // Check if line represents a zero-bit, by counting black pixels in the\r\n        // centre area of the line.\r\n        const zeroX1 = Math.floor(x1 + Writer.BIT_ZERO_OFFSET * this.scale);\r\n        const zeroX2 = Math.ceil(x2 - Writer.BIT_ZERO_OFFSET * this.scale);\r\n        const zeroWidth = zeroX2 - zeroX1 + 1;\r\n        const blackCentre = this.countBlackInLine(matrix, zeroX1, y, zeroX2, y);\r\n        if (blackCentre / zeroWidth < Extractor.LINE_ONE_BLACK_THRESHOLD) {\r\n            return Extractor.LINE_STATE_ZERO;\r\n        }\r\n\r\n        // Line represents a one-bit.\r\n        return Extractor.LINE_STATE_ONE;\r\n    }\r\n}\r\n","import { BitMatrix } from \"../../BitMatrix\";\r\nimport { Point } from \"../../geometry\";\r\nimport { EncodedIChing } from \"../EncodedIChing\";\r\n\r\n/**\r\n * Writer class encapsulating IChing rendering methods.\r\n *\r\n * @export\r\n * @class Writer\r\n */\r\nexport class Writer {\r\n    /**\r\n     * UNIT_DIM - Basic \"unit\" dimension in pixels. All other dimensions are based on this.\r\n     */\r\n    public static UNIT_DIM: number = 2;\r\n    /**\r\n     * BITS_PER_SYMBOL - Number of bits represented in a single symbol.\r\n     */\r\n    public static BITS_PER_SYMBOL: number = 6;\r\n    /**\r\n     * SYMBOL_DIM - Height/width of a single symbol.\r\n     */\r\n    public static SYMBOL_DIM: number = (Writer.BITS_PER_SYMBOL * 2 - 1) * Writer.UNIT_DIM;\r\n    /**\r\n     * BIT_ZERO_OFFSET - Offset, from the left edge of the symbol,\r\n     * of the middle bit area to be cleared if bit is zero.\r\n     */\r\n    public static BIT_ZERO_OFFSET: number = Writer.UNIT_DIM * 4.5;\r\n    /**\r\n     * BIT_ZERO_WIDTH - Width of the middle bit area to be cleared if bit is zero.\r\n     */\r\n    public static BIT_ZERO_WIDTH: number = Writer.UNIT_DIM * 2;\r\n    /**\r\n     * GAP_DIM - Size of the gap between any two adjacent symbols.\r\n     */\r\n    public static GAP_DIM: number = Writer.UNIT_DIM * 3;\r\n    /**\r\n     * FINDER_OUTER_RADIUS - Radius of the finder pattern's outer ring.\r\n     */\r\n    public static FINDER_OUTER_RADIUS: number = Writer.SYMBOL_DIM * 0.5;\r\n    /**\r\n     * FINDER_MIDDLE_RADIUS - Radius of the finder pattern's middle ring.\r\n     */\r\n    public static FINDER_MIDDLE_RADIUS: number = Writer.FINDER_OUTER_RADIUS * 5 / 7;\r\n    /**\r\n     * FINDER_INNER_RADIUS - Radius of the finder pattern's inner ring.\r\n     */\r\n    public static FINDER_INNER_RADIUS: number = Writer.FINDER_OUTER_RADIUS * 3 / 7;\r\n    /**\r\n     * QUIET_ZONE - Size of the quiet zone around the rendered symbol.\r\n     */\r\n    public static QUIET_ZONE: number = Writer.SYMBOL_DIM;\r\n\r\n    private matrix: BitMatrix;\r\n    private scale: number;\r\n    private resolution: number;\r\n    private roundEdges: boolean;\r\n    private inverted: boolean;\r\n    private pad: number;\r\n\r\n    /**\r\n     * Creates an instance of Writer.\r\n     *\r\n     * @param {number} - desired height and width of the rendered image.\r\n     */\r\n    public constructor(resolution: number, roundEdges: boolean, inverted: boolean) {\r\n        this.resolution = resolution;\r\n        this.roundEdges = roundEdges;\r\n        this.inverted = inverted;\r\n    }\r\n\r\n    /**\r\n     * Renders the provided encoded IChing.\r\n     * It takes an EncodedIChing object with the version, size, and data fields set,\r\n     * and sets the imageData field.\r\n     *\r\n     * @param {EncodedIChing} code - Object representing an encoded IChing.\r\n     * @returns {void}\r\n     */\r\n    public render(code: EncodedIChing): void {\r\n        const codeSize = code.size;\r\n        // Minimum image dimension.\r\n        const baseDimension = codeSize * Writer.SYMBOL_DIM + (codeSize - 1) * Writer.GAP_DIM\r\n            + (Writer.FINDER_OUTER_RADIUS * 2 + Writer.QUIET_ZONE) * 2;\r\n\r\n        // Calculate scaling factor based on base dimensions and desired output image dimension.\r\n        this.scale = Math.floor(this.resolution / baseDimension);\r\n        if (this.scale < 1) {\r\n            throw new Error(\"Resolution is too small!\");\r\n        }\r\n\r\n        // Creates a BitMatrix filled with 0s.\r\n        this.matrix = new BitMatrix(this.resolution, this.resolution);\r\n\r\n        // Calculate padding.\r\n        this.pad = Math.floor((this.resolution - baseDimension * this.scale) / 2);\r\n\r\n        // Draw finder patterns.\r\n        const finderOffset = (Writer.QUIET_ZONE + Writer.FINDER_OUTER_RADIUS) * this.scale\r\n            + this.pad;\r\n        this.drawFinderPattern({ x: finderOffset, y: finderOffset });\r\n        this.drawFinderPattern({ x: this.resolution - finderOffset, y: finderOffset });\r\n        this.drawFinderPattern({ x: finderOffset, y: this.resolution - finderOffset });\r\n\r\n        // Draw alignment pattern.\r\n        this.drawAlignmentPattern(\r\n            { x: this.resolution - finderOffset, y: this.resolution - finderOffset },\r\n        );\r\n\r\n        // Draw symbols.\r\n        for (let i = 0; i < codeSize; i++) {\r\n            for (let j = 0; j < codeSize; j++) {\r\n                this.drawSymbol(i, j, code.data[i * codeSize + j]);\r\n            }\r\n        }\r\n\r\n        // If inverted flag is set, invert colours.\r\n        if (this.inverted) {\r\n            for (let i = 0; i < this.resolution; i++) {\r\n                for (let j = 0; j < this.resolution; j++) {\r\n                    this.matrix.set(i, j, 1 - this.matrix.get(i, j));\r\n                }\r\n            }\r\n        }\r\n\r\n        code.imageData = this.matrix.toImage();\r\n    }\r\n\r\n    private drawFinderPattern(centre: Point): void {\r\n        const r1 = Writer.FINDER_INNER_RADIUS * this.scale;\r\n        const r2 = Writer.FINDER_MIDDLE_RADIUS * this.scale;\r\n        const r3 = Writer.FINDER_OUTER_RADIUS * this.scale;\r\n\r\n        // Outer black ring.\r\n        this.fillCircle(centre, r3, 1);\r\n\r\n        // Middle white ring.\r\n        this.fillCircle(centre, r2, 0);\r\n\r\n        // Inner black circle.\r\n        this.fillCircle(centre, r1, 1);\r\n    }\r\n\r\n    private drawAlignmentPattern(centre: Point): void {\r\n        const r1 = Writer.FINDER_INNER_RADIUS * this.scale;\r\n        const r2 = Writer.FINDER_MIDDLE_RADIUS * this.scale;\r\n\r\n        // Outer black ring.\r\n        this.fillCircle(centre, r2, 1);\r\n\r\n        // Inner white circle.\r\n        this.fillCircle(centre, r1, 0);\r\n    }\r\n\r\n    /**\r\n     * Draws a filled circle with the given parameters, using Bresenham's circle drawing algorithm.\r\n     *\r\n     * @see [this page]{@link https://web.engr.oregonstate.edu/~sllu/bcircle.pdf}\r\n     * for more info.\r\n     */\r\n    private fillCircle(c: Point, r: number, color: number): void {\r\n        r = Math.round(r);\r\n        c = { x: Math.round(c.x), y: Math.round(c.y) };\r\n\r\n        let x = r;\r\n        let y = 0;\r\n        let dx = 1 - r * 2;\r\n        let dy = 1;\r\n        let err = 0;\r\n        while (x >= y) {\r\n            this.fillSymmetricOctant(c, x, y, color);\r\n            y++;\r\n            err += dy;\r\n            dy += 2;\r\n            if (2 * err + dx > 0) {\r\n                x--;\r\n                err += dx;\r\n                dx += 2;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes pixel coordinates on a circle's circumference in one octant and fills symmetrically in\r\n     * all 8 octants, relative to the given centre.\r\n     */\r\n    private fillSymmetricOctant(c: Point, x: number, y: number, color: number): void {\r\n        this.fillHorizontalLine(c.x - x, c.x + x, c.y + y, color);\r\n        this.fillHorizontalLine(c.x - x, c.x + x, c.y - y, color);\r\n        this.fillHorizontalLine(c.x - y, c.x + y, c.y + x, color);\r\n        this.fillHorizontalLine(c.x - y, c.x + y, c.y - x, color);\r\n    }\r\n\r\n    /**\r\n     * Fills the horizontal line from (x1, y) to (x2, y) with the desired color.\r\n     */\r\n    private fillHorizontalLine(x1: number, x2: number, y: number, color: number) {\r\n        for (let i = x1; i <= x2; i++) {\r\n            this.matrix.set(i, y, color);\r\n        }\r\n    }\r\n\r\n    private drawSymbol(row: number, col: number, mask: number): void {\r\n        const gridOffset = Writer.QUIET_ZONE + Writer.FINDER_OUTER_RADIUS * 2;\r\n        const startX = (col * (Writer.SYMBOL_DIM + Writer.GAP_DIM) + gridOffset) * this.scale\r\n            + this.pad;\r\n        const startY = (row * (Writer.SYMBOL_DIM + Writer.GAP_DIM) + gridOffset) * this.scale\r\n            + this.pad;\r\n        const bitWidth = Writer.SYMBOL_DIM * this.scale;\r\n        const bitHeight = Writer.UNIT_DIM * this.scale;\r\n        const zeroOffset = Writer.BIT_ZERO_OFFSET * this.scale;\r\n        const zeroWidth = Writer.BIT_ZERO_WIDTH * this.scale;\r\n        const edgeRadius = bitHeight / 2 - 1;\r\n\r\n        for (let bit = 0, x = startX, y = startY; bit < Writer.BITS_PER_SYMBOL;\r\n                bit++, y += bitHeight * 2) {\r\n            // Draw a filled rectangle representing the bit.\r\n            this.fillRect(x + edgeRadius, y, bitWidth - 2 * edgeRadius, bitHeight, 1);\r\n\r\n            if (this.roundEdges) {\r\n                // Rounded left edge.\r\n                this.fillCircle({ x: x + edgeRadius, y: y + edgeRadius }, edgeRadius, 1);\r\n                this.fillCircle({ x: x + edgeRadius, y: y + edgeRadius + 1 }, edgeRadius, 1);\r\n                // Rounded right edge.\r\n                this.fillCircle({ x: x + bitWidth - edgeRadius, y: y + edgeRadius }, edgeRadius, 1);\r\n                this.fillCircle(\r\n                    { x: x + bitWidth - edgeRadius, y: y + edgeRadius + 1 }, edgeRadius, 1,\r\n                );\r\n            } else {\r\n                // Straight edges.\r\n                this.fillRect(x, y, edgeRadius, bitHeight, 1);\r\n                this.fillRect(x + bitWidth - edgeRadius, y, edgeRadius, bitHeight, 1);\r\n            }\r\n\r\n            // If bit is zero, clear middle area.\r\n            if ((mask & (1 << bit)) === 0) {\r\n                this.fillRect(x + zeroOffset - edgeRadius, y,\r\n                    zeroWidth + 2 * edgeRadius, bitHeight, 0);\r\n\r\n                if (this.roundEdges) {\r\n                    // Rounded right edge of the left half.\r\n                    this.fillCircle(\r\n                        { x: x + zeroOffset - edgeRadius, y: y + edgeRadius },\r\n                        edgeRadius, 1,\r\n                    );\r\n                    this.fillCircle(\r\n                        { x: x + zeroOffset - edgeRadius, y: y + edgeRadius + 1 },\r\n                        edgeRadius, 1,\r\n                    );\r\n                    // Rounded left egde of the right half.\r\n                    this.fillCircle(\r\n                        { x: x + zeroOffset + zeroWidth + edgeRadius, y: y + edgeRadius },\r\n                        edgeRadius, 1,\r\n                    );\r\n                    this.fillCircle(\r\n                        { x: x + zeroOffset + zeroWidth + edgeRadius, y: y + edgeRadius + 1 },\r\n                        edgeRadius, 1,\r\n                    );\r\n                } else {\r\n                    // Straight edges.\r\n                    this.fillRect(x + zeroOffset - edgeRadius, y, edgeRadius, bitHeight, 1);\r\n                    this.fillRect(x + zeroOffset + zeroWidth, y, edgeRadius, bitHeight, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Draws a filled rectangle with given parameters.\r\n    private fillRect(x: number, y: number, width: number, height: number, color: number): void {\r\n        for (let i = 0; i < height; i++) {\r\n            for (let j = 0; j < width; j++) {\r\n                this.matrix.set(x + j, y + i, color);\r\n            }\r\n        }\r\n    }\r\n}\r\n","export { Locator } from \"./Locator\";\r\n","import { BitMatrix } from \"../../BitMatrix\";\r\nimport { cross, distance, nearlySame, Point, sqDistance, vec } from \"../../geometry\";\r\nimport { PatternsLocation } from \"../PatternsLocation\";\r\nimport { LocationError } from \"./LocationError\";\r\nimport { PatternLocator } from \"./PatternLocator\";\r\n\r\nexport class Locator {\r\n    /**\r\n     * Minimum distance between finder patterns.\r\n     */\r\n    public static MIN_PATTERN_DIST = 50;\r\n\r\n    /**\r\n     * The ratio of alignment pattern size to finder pattern size.\r\n     */\r\n    public static ALIGNMENT_TO_FINDER_RATIO = 5 / 7;\r\n\r\n    /**\r\n     * The maximum tolerance allowed for a pattern size to differentiate than its estimated size.\r\n     */\r\n    public static LOOSE_SIZE_TOLERANCE = 5;\r\n\r\n    /**\r\n     * A lower tolerance value allowed for a pattern size to differentiate than its estimated size.\r\n     */\r\n    public static CONFINED_SIZE_TOLERANCE = 4;\r\n\r\n    /**\r\n     * Finder pattern ratios between white and black states.\r\n     */\r\n    public static FINDER_RATIOS = new Uint8Array([ 1, 1, 3, 1, 1 ]);\r\n\r\n    /**\r\n     * Alignment pattern ratios between white and black states.\r\n     */\r\n    public static ALIGNMENT_RATIOS = new Uint8Array([ 1, 3, 1 ]);\r\n\r\n    private matrix: BitMatrix;\r\n    private locations: PatternsLocation;\r\n\r\n    /**\r\n     * Main class method, locate the finder and alignment patterns\r\n     *\r\n     * @param {BitMatrix} matrix - Matrix representing binarized image.\r\n     * @returns {PatternsLocation} - Locations of the finder and alignment patterns.\r\n     * @memberof Locator\r\n     */\r\n    public locate(matrix: BitMatrix): PatternsLocation {\r\n        this.matrix = matrix;\r\n        this.locations = {} as PatternsLocation;\r\n        /**\r\n         * compare function to sort location according to error in accending order.\r\n         */\r\n        const compareError = (a: LocationError, b: LocationError): number => (a.error - b.error);\r\n\r\n        // Locate Finder Patterns.\r\n        const patternLocator = new PatternLocator();\r\n        const finders = patternLocator.locate(this.matrix, Locator.FINDER_RATIOS);\r\n\r\n        // Sort the array of found patterns to pick the three with the smallest error.\r\n        finders.sort(compareError);\r\n\r\n        // First we get the least error three distinct finder patterns without checking their sizes.\r\n        let optimalFinders = this.findOptimalPatterns(finders);\r\n        // Then we get the optimal finder patterns by checking each one size against estimated size.\r\n        // Making the estimate size equal to the maximum among our first guess patterns makes since\r\n        // because it's harder for large objects to achieve the required finder patterns ratio.\r\n        const estimatedFinderSize = Math.max(\r\n            optimalFinders[0].size, optimalFinders[1].size, optimalFinders[2].size,\r\n        );\r\n        optimalFinders = this.findOptimalPatterns(finders, estimatedFinderSize);\r\n\r\n        this.assignFinders(\r\n            optimalFinders[0].location,\r\n            optimalFinders[1].location,\r\n            optimalFinders[2].location,\r\n        );\r\n        this.locations.finderAverageSize = (\r\n            optimalFinders[0].size +\r\n            optimalFinders[1].size +\r\n            optimalFinders[2].size\r\n        ) / 3;\r\n\r\n        // Calculate the estimated location and size of the bottom-right alignment pattern\r\n        this.locations.bottomRight = {\r\n            x: this.locations.topRight.x - this.locations.topLeft.x + this.locations.bottomLeft.x,\r\n            y: this.locations.topRight.y - this.locations.topLeft.y + this.locations.bottomLeft.y,\r\n        };\r\n        this.locations.alignmentSize =\r\n            this.locations.finderAverageSize * Locator.ALIGNMENT_TO_FINDER_RATIO;\r\n\r\n        // Average distance between patterns\r\n        let patternsDistance = distance(this.locations.topLeft, this.locations.topRight);\r\n        patternsDistance += distance(this.locations.topLeft, this.locations.bottomLeft);\r\n        patternsDistance = Math.round(patternsDistance / 2);\r\n\r\n        // Calculate the search region for the alignment pattern locator\r\n        // Search start point\r\n        const startPoint: Point = {\r\n            x: Math.max(0, this.locations.bottomRight.x - (patternsDistance)),\r\n            y: Math.max(0, this.locations.bottomRight.y - (patternsDistance)),\r\n        };\r\n\r\n        // Search end point\r\n        const endPoint: Point = {\r\n            x: Math.min(matrix.width, this.locations.bottomRight.x + (patternsDistance)),\r\n            y: Math.min(matrix.height, this.locations.bottomRight.y + (patternsDistance)),\r\n        };\r\n\r\n        // Locate Alignment patterns.\r\n        const alignments = patternLocator.locate(\r\n            this.matrix, Locator.ALIGNMENT_RATIOS,\r\n            true, startPoint, endPoint,\r\n        );\r\n\r\n        const estimatedAlignmentSize = this.locations.alignmentSize;\r\n        if (alignments.length > 0) {\r\n            // Sort the array of found patterns to pick the one with the smallest error.\r\n            alignments.sort(compareError);\r\n            for (const pattern of alignments) {\r\n                // If the pattern size is not far away different than the expected,\r\n                // then consider it as the alignment pattern.\r\n                // Used a loose tolerance if the pattern are larger than the expected, because it's\r\n                // harder for large objects to form the required pattern ratio.\r\n                if (\r\n                    pattern.size < Locator.LOOSE_SIZE_TOLERANCE * estimatedAlignmentSize &&\r\n                    pattern.size * Locator.CONFINED_SIZE_TOLERANCE > estimatedAlignmentSize\r\n                ) {\r\n                    this.locations.bottomRight = pattern.location;\r\n                    this.locations.alignmentSize = pattern.size;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.locations;\r\n    }\r\n\r\n    /**\r\n     * Finds the distinct finder patterns matching a certain size with tolerance equal to\r\n     * LOOSE_SIZE_TOLERANCE*100%.\r\n     *\r\n     * @private\r\n     * @param {LocationError[]} finders - Potential Finder patterns.\r\n     * @param {number} [estimatedSize] - Size to check against, if not passed then no\r\n     * size check happens.\r\n     * @returns {LocationError[]} - The least error three distinct finder patterns.\r\n     * @memberof Locator\r\n     * @throws Error if there're no at least three distinct patterns matches the size.\r\n     */\r\n    private findOptimalPatterns(finders: LocationError[], estimatedSize?: number): LocationError[] {\r\n        const optimalFinders: LocationError[] = [];\r\n        for (let i = 0; i < finders.length && optimalFinders.length < 3; ++i) {\r\n            // Check if points are actually distinct\r\n            let distinctPoint = true;\r\n            for (const oldPattern of optimalFinders) {\r\n                if (nearlySame(\r\n                    oldPattern.location,\r\n                    finders[i].location,\r\n                    Locator.MIN_PATTERN_DIST,\r\n                )) {\r\n                    distinctPoint = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (distinctPoint) {\r\n                // If it's a new pattern then check that it's size isn't far\r\n                // away from the estimated size.\r\n                // Used a loose tolerance if the pattern are larger than the expected, because it's\r\n                // harder for large objects to form the required pattern ratio.\r\n                if (\r\n                    !estimatedSize ||\r\n                    (finders[i].size < Locator.LOOSE_SIZE_TOLERANCE * estimatedSize &&\r\n                    finders[i].size * Locator.CONFINED_SIZE_TOLERANCE > estimatedSize)\r\n                ) {\r\n                    // If all is good then add it to optimalFinders\r\n                    optimalFinders.push(finders[i]);\r\n                }\r\n            }\r\n        }\r\n        if (optimalFinders.length < 3) {\r\n            throw new Error(\"Couldn't Locate Finder Patterns!\");\r\n        }\r\n\r\n        return optimalFinders;\r\n    }\r\n\r\n    /**\r\n     * Reorder finder patterns and assign them to the returned object.\r\n     *\r\n     * @private\r\n     * @param {Point} a\r\n     * @param {Point} b\r\n     * @param {Point} c\r\n     * @memberof Locator\r\n     */\r\n    private assignFinders(a: Point, b: Point, c: Point) {\r\n        // The topRight and the bottomLeft patterns should have the longest distance\r\n        // so we assign them to variables `a` and `b`\r\n        const distAB = sqDistance(a, b);\r\n        const distAC = sqDistance(a, c);\r\n        const distBC = sqDistance(b, c);\r\n        // Make sure that vector AB has the longest distance\r\n        if (distAC > distAB && distAC > distBC) {\r\n            [c, b] = [b, c];\r\n        } else if (distBC > distAB) {\r\n            [c, a] = [a, c];\r\n        }\r\n        // Now the third point should be on the left from vector (bottomLeft -> topRight)\r\n        // We use cross product to check if that's correct\r\n        // If not then we swap the two points in order for variable `a` to hold bottomLeft\r\n        // and variable `b` to hold topRight\r\n        if (cross(vec(a, b), vec(a, c)) > 0) {\r\n            [a, b] = [b, a];\r\n        }\r\n\r\n        // assign finder patterns to the returned object and assign alignment pattern to\r\n        // null in case we didn't find any.\r\n        this.locations.bottomLeft = a;\r\n        this.locations.topRight = b;\r\n        this.locations.topLeft = c;\r\n    }\r\n}\r\n","export { CodeTransform } from \"./CodeTranform\";\r\n","import { BitMatrix } from \"../../BitMatrix\";\r\nimport { distance } from \"../../geometry\";\r\nimport { PatternsLocation } from \"../PatternsLocation\";\r\nimport { PerspectiveTransform } from \"./PerspectiveTransform\";\r\n\r\n/**\r\n * @export\r\n * @class CodeTransform\r\n * @description Transforms a BitMatrix perspective to match the standard IChing code perspective\r\n * with the finder patterns as corners.\r\n */\r\nexport class CodeTransform {\r\n    /**\r\n     * Transforms Bitmatrix perspective.\r\n     *\r\n     * @param {BitMatrix} srcMatrix - The original BitMatrix, to be transformed.\r\n     * @param {PatternsLocation} patterns - The location of the corner patterns to guid the\r\n     * new perspective.\r\n     * @returns {BitMatrix} - The new transformed matrix.\r\n     * @memberof CodeTransform\r\n     */\r\n    public transform(srcMatrix: BitMatrix, patterns: PatternsLocation): BitMatrix {\r\n        // calculate the approximate dimensions of the embedded IChing code by taking the\r\n        // average distance between vertical and horizontal patterns.\r\n        const dimension = Math.round((\r\n            distance(patterns.topLeft, patterns.topRight) +\r\n            distance(patterns.topLeft, patterns.bottomLeft)\r\n        ) / 2);\r\n\r\n        // instead of mapping each pixel in the old matrix to its corresponding pixel/pixels in\r\n        // the new matrix, we reversed the operation by mapping the new one to the old, that\r\n        // makes better sense, since we don't have to compress or expand any pixels.\r\n        // So we send the distination matrix corners as the source corners.\r\n        const transformer = new PerspectiveTransform([\r\n            { x: dimension - 1, y: 0 },\r\n            { x: 0, y: 0 },\r\n            { x: 0, y: dimension - 1 },\r\n            { x: dimension - 1, y: dimension - 1 },\r\n        ], [\r\n            patterns.topRight,\r\n            patterns.topLeft,\r\n            patterns.bottomLeft,\r\n            patterns.bottomRight,\r\n        ]);\r\n\r\n        const distMatrix = new BitMatrix(dimension, dimension);\r\n        for (let x = 0; x < dimension; ++x) {\r\n            for (let y = 0; y < dimension; ++y) {\r\n                let srcPoint = transformer.transform({ x, y });\r\n                srcPoint = { x: Math.round(srcPoint.x), y: Math.round(srcPoint.y) };\r\n                // mapp each pixel in the new matrix to the corresponding pixel in the old one.\r\n                distMatrix.set(x, y, srcMatrix.get(srcPoint.x, srcPoint.y));\r\n            }\r\n        }\r\n\r\n        return distMatrix;\r\n    }\r\n}\r\n","/**\r\n * Most of this module logic is direct implementation of George Wolberg's book\r\n * \"Digital Image Warping\" section 3.4.2\r\n */\r\nimport { Point } from \"../../geometry\";\r\nimport { TransformationMatrix } from \"./TransformationMatrix\";\r\n\r\n/**\r\n * @class PerspectiveTransform\r\n * @description Calculates perspective transformation matrix to transform any arbitrary\r\n * quadrilateral to another.\r\n * @export\r\n */\r\nexport class PerspectiveTransform {\r\n    private mat: TransformationMatrix;\r\n    /**\r\n     * Creates an instance of PerspectiveTransform to transform any point prespective to\r\n     *  match the distination quadrilateral prespective.\r\n     * @param {Point[]} srcCorners - Source quadrilateral corner coordinates.\r\n     * @param {Point[]} distCorners - Distination quadrilateral corner coordinates.\r\n     * @memberof PerspectiveTransform\r\n     */\r\n    constructor(srcCorners: Point[], distCorners: Point[]) {\r\n        if (srcCorners.length !== 4 || distCorners.length !== 4) {\r\n            throw new Error(\"Both source and distination point have to be exactly four points!\");\r\n        }\r\n\r\n        // Calculate transformation matrix to convert our quadrilateral to unit square then\r\n        // another matrix to covert unit square to the destination quadrilateral.\r\n        this.mat = this.quadrilateralToUnitSquareMatrix(\r\n            srcCorners[0].x, srcCorners[0].y,\r\n            srcCorners[1].x, srcCorners[1].y,\r\n            srcCorners[2].x, srcCorners[2].y,\r\n            srcCorners[3].x, srcCorners[3].y,\r\n        ).times(this.unitSquareToQuadrilateralMatrix(\r\n            distCorners[0].x, distCorners[0].y,\r\n            distCorners[1].x, distCorners[1].y,\r\n            distCorners[2].x, distCorners[2].y,\r\n            distCorners[3].x, distCorners[3].y,\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * Transform point according to the precalculated perspective transformation matrix\r\n     *\r\n     * @param {Point} srcPoint - Point to be transformed.\r\n     * @returns {Point} - Transformed point\r\n     * @memberof PerspectiveTransform\r\n     */\r\n    public transform(srcPoint: Point): Point {\r\n        const denominator = this.mat.dotColumn(2, [srcPoint.x, srcPoint.y, 1]);\r\n        return {\r\n            x: this.mat.dotColumn(0, [srcPoint.x, srcPoint.y, 1]) / denominator,\r\n            y: this.mat.dotColumn(1, [srcPoint.x, srcPoint.y, 1]) / denominator,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calculates the transformation matrix any quadrilateral shape to unit square.\r\n     * @see https://en.wikipedia.org/wiki/Minor_(linear_algebra)#Inverse_of_a_matrix\r\n     *\r\n     * @private\r\n     * @param {number} xi - X cordinates for quadrilateral corner points.\r\n     * @param {number} yi - Y cordinates for quadrilateral corner points.\r\n     * @returns {TransformationMatrix}\r\n     * @memberof PerspectiveTransform\r\n     */\r\n    private quadrilateralToUnitSquareMatrix(\r\n        x0: number, y0: number,\r\n        x1: number, y1: number,\r\n        x2: number, y2: number,\r\n        x3: number, y3: number,\r\n    ): TransformationMatrix {\r\n        // as described in the reference link Inv(A) = Adjugate(A) / det(A), but since\r\n        // two matrices which are (nonzero) scalar multiples of each other are equivalent in\r\n        // the homogeneous coordinate system, there is no need to divide by the determinant.\r\n        return this.unitSquareToQuadrilateralMatrix(x0, y0, x1, y1, x2, y2, x3, y3).adjugate();\r\n    }\r\n\r\n    /**\r\n     * Calculates the transformation matrix to transform unit square to any quadrilateral shape.\r\n     *\r\n     * @private\r\n     * @param {number} xi - X cordinates for quadrilateral corner points.\r\n     * @param {number} yi - Y cordinates for quadrilateral corner points.\r\n     * @returns {TransformationMatrix}\r\n     * @memberof PerspectiveTransform\r\n     */\r\n    private unitSquareToQuadrilateralMatrix(\r\n        x0: number, y0: number,\r\n        x1: number, y1: number,\r\n        x2: number, y2: number,\r\n        x3: number, y3: number,\r\n    ): TransformationMatrix {\r\n        // all function logic is direct implementation of\r\n        // George Wolberg's book \"Digital Image Warping\" section 3.4.2\r\n        const dx1 = x1 - x2;\r\n        const dx2 = x3 - x2;\r\n        const dx3 = x0 - x1 + x2 - x3;\r\n        const dy1 = y1 - y2;\r\n        const dy2 = y3 - y2;\r\n        const dy3 = y0 - y1 + y2 - y3;\r\n\r\n        const denominator = dx1 * dy2 - dx2 * dy1;\r\n        const transformationMatrix = new TransformationMatrix();\r\n        // If dx3 and dy3 is zeros, then that's an affine transformation and a02, a12 values will\r\n        // be zeros resulting to simplify the output to affine transformation matrix.\r\n        const a02 = (dx3 * dy2 - dx2 * dy3) / denominator;\r\n        const a12 = (dx1 * dy3 - dx3 * dy1) / denominator;\r\n\r\n        transformationMatrix.set(0, 0, x1 - x0 + a02 * x1);\r\n        transformationMatrix.set(1, 0, x3 - x0 + a12 * x3);\r\n        transformationMatrix.set(2, 0, x0);\r\n        transformationMatrix.set(0, 1, y1 - y0 + a02 * y1);\r\n        transformationMatrix.set(1, 1, y3 - y0 + a12 * y3);\r\n        transformationMatrix.set(2, 1, y0);\r\n        transformationMatrix.set(0, 2, a02);\r\n        transformationMatrix.set(1, 2, a12);\r\n        transformationMatrix.set(2, 2, 1.0);\r\n\r\n        return transformationMatrix;\r\n    }\r\n}\r\n","/**\r\n * 2D 3 x 3 matrix of numbers representing 2D transformation matrix.\r\n */\r\nexport class TransformationMatrix {\r\n    private A: Float32Array[];\r\n\r\n    constructor(other ?: TransformationMatrix) {\r\n        this.A = [];\r\n        for (let i = 0; i < 3; ++i) {\r\n            this.A.push(new Float32Array(3));\r\n        }\r\n        if (other !== null && other !== undefined) {\r\n            for (let i = 0; i < 3; ++i) {\r\n                for (let j = 0; j < 3; ++j) {\r\n                    this.A[i][j] = other.A[i][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public get(x: number, y: number): number {\r\n        return this.A[x][y];\r\n    }\r\n\r\n    public set(x: number, y: number, val: number) {\r\n        this.A[x][y] = val;\r\n    }\r\n\r\n    /**\r\n     * Calculates the dot product between certain row and other vector.\r\n     *\r\n     * @param {number} row - Row number\r\n     * @param {number[]} other - Vector to multiply the row with\r\n     * @returns {number} - Dot product result\r\n     * @memberof TransformationMatrix\r\n     */\r\n    public dotRow(row: number, other: number[]): number {\r\n        if (other.length !== 3) {\r\n            throw new Error(\"The Other vector has to be of length 3!\");\r\n        }\r\n        return this.A[row][0] * other[0] + this.A[row][1] * other[1] + this.A[row][2] * other[2];\r\n    }\r\n\r\n    /**\r\n     * Calculates the dot product between certain column and other vector.\r\n     *\r\n     * @param {number} col - Column number\r\n     * @param {number[]} other - Vector to multiply the column with\r\n     * @returns {number} - Dot product result\r\n     * @memberof TransformationMatrix\r\n     */\r\n    public dotColumn(col: number, other: number[]): number {\r\n        if (other.length !== 3) {\r\n            throw new Error(\"The Other vector has to be of length 3!\");\r\n        }\r\n        return this.A[0][col] * other[0] + this.A[1][col] * other[1] + this.A[2][col] * other[2];\r\n    }\r\n\r\n    /**\r\n     * Calculate the cofactor matrix in order to calculate the adjugate matrix.\r\n     * @see https://en.wikipedia.org/wiki/Minor_(linear_algebra)#Inverse_of_a_matrix\r\n     *\r\n     * @returns {TransformationMatrix} - Cofactor matrix\r\n     * @memberof TransformationMatrix\r\n     */\r\n    public cofactor(): TransformationMatrix {\r\n        const cofactorMatrix = new TransformationMatrix();\r\n        const B = cofactorMatrix.A;\r\n        const A = this.A;\r\n        for (let i = 0, sign = 1; i < 3; ++i) {\r\n            for (let j = 0; j < 3; ++j, sign *= -1) {\r\n                const rows: number[] = [];\r\n                const cols: number[] = [];\r\n                for (let k = 0; k < 3; ++k) {\r\n                    // skip each element row and column to calculate the determinates.\r\n                    if (k !== i) {\r\n                        rows.push(k);\r\n                    }\r\n                    if (k !== j) {\r\n                        cols.push(k);\r\n                    }\r\n                }\r\n                // calculate each deteminante value.\r\n                B[i][j] = sign * (\r\n                    A[rows[0]][cols[0]] * A[rows[1]][cols[1]] -\r\n                    A[rows[0]][cols[1]] * A[rows[1]][cols[0]]\r\n                );\r\n            }\r\n        }\r\n        return cofactorMatrix;\r\n    }\r\n\r\n    /**\r\n     * Calculates the matrix transpose.\r\n     *\r\n     * @returns {TransformationMatrix} - Matrix transpose\r\n     * @memberof TransformationMatrix\r\n     */\r\n    public transpose(): TransformationMatrix {\r\n        const transposed = new TransformationMatrix();\r\n        const B = transposed.A;\r\n        const A = this.A;\r\n        for (let i = 0; i < 3; ++i) {\r\n            for (let j = 0; j < 3; ++j) {\r\n                B[j][i] = A[i][j];\r\n            }\r\n        }\r\n        return transposed;\r\n    }\r\n\r\n    /**\r\n     * Calculates the adjugate matrix.\r\n     * @see https://en.wikipedia.org/wiki/Adjugate_matrix\r\n     *\r\n     * @returns {TransformationMatrix}\r\n     * @memberof TransformationMatrix - Adjugate matrix\r\n     */\r\n    public adjugate(): TransformationMatrix {\r\n        return this.cofactor().transpose();\r\n    }\r\n\r\n    /**\r\n     * Multiplies by another matrix.\r\n     *\r\n     * @param {TransformationMatrix} other\r\n     * @returns {TransformationMatrix} - Multiplications result\r\n     * @memberof TransformationMatrix\r\n     */\r\n    public times(other: TransformationMatrix): TransformationMatrix {\r\n        const result = new TransformationMatrix();\r\n        const C = result.A;\r\n        const B = other.A;\r\n        const A = this.A;\r\n        for (let i = 0; i < 3; ++i) {\r\n            for (let j = 0; j < 3; ++j) {\r\n                C[i][j] = 0;\r\n                for (let k = 0; k < 3; ++k) {\r\n                    C[i][j] += A[i][k] * B[k][j];\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n}\r\n","import { EncodedIChing } from \"./EncodedIChing\";\r\nimport { Encoder } from \"./Encoder\";\r\nimport { Writer } from \"./writer\";\r\n\r\n/**\r\n * Encoder optional parameters.\r\n *\r\n * @interface EncoderOptions\r\n */\r\nexport interface EncoderOptions {\r\n    /**\r\n     * Percentage of symbols that can be corrected after encoding, must be between 0 - 1.\r\n     * Default value is 0.15.\r\n     */\r\n    ecLevel?: number;\r\n    /**\r\n     * Desired height and width of the rendered image.\r\n     * Default value is 1250.\r\n     */\r\n    resolution?: number;\r\n    /**\r\n     * Boolean determining whether the symbols' edges in the rendered image are straight or round.\r\n     * Default value is false.\r\n     */\r\n    roundEdges?: boolean;\r\n    /**\r\n     * Boolean determining whether the output image is inverted, i.e. white on black instead of\r\n     * black on white. Default value is false.\r\n     */\r\n    inverted?: boolean;\r\n}\r\n\r\n/**\r\n * Encoder entry point - Encodes plain text in IChing RGBA image.\r\n *\r\n * @export\r\n * @param {string} payload\r\n * @param {EncoderOptions} [options]\r\n * @returns {EncodedIChing} - Encoded image data alongside code metadata.\r\n */\r\nexport function encode(payload: string, options?: EncoderOptions): EncodedIChing {\r\n    options = options || {};\r\n    if (options.ecLevel === undefined || options.ecLevel === null) {\r\n        options.ecLevel = Encoder.EC_MEDIUM;\r\n    }\r\n\r\n    if (options.resolution === undefined || options.resolution === null) {\r\n        options.resolution = 1250;\r\n    }\r\n\r\n    if (options.roundEdges === undefined || options.roundEdges === null) {\r\n        options.roundEdges = false;\r\n    }\r\n\r\n    if (options.inverted === undefined || options.inverted === null) {\r\n        options.inverted = false;\r\n    }\r\n\r\n    const encoder = new Encoder();\r\n    const encodedData = encoder.encode(payload, options.ecLevel);\r\n\r\n    const writer = new Writer(options.resolution, options.roundEdges, options.inverted);\r\n    writer.render(encodedData);\r\n\r\n    return encodedData;\r\n}\r\n"],"sourceRoot":""}